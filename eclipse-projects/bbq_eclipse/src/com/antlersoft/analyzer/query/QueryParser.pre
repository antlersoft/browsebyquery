package analyzer.query;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.PrintStream;
import analyzer.*;
import parser.*;

public class QueryParser extends Parser
{
    // Public interface
    public QueryParser( String toParse)
    {
        this();
        setLine( toParse);
    }

    public QueryParser()
    {
        super( parseStates);
        tokens=null;
        previousSet=null;
        storedValues=new HashMap();
        storedValuesSupport=new PropertyChangeSupport( this);
    }
  
    public SetExpression getExpression()
        throws ParseException
    {
        currentIndex=0;
        boolean errorOut=false;
        for (; ! errorOut && currentIndex<tokens.length; currentIndex++)
        {
            errorOut=parse( tokens[currentIndex].symbol, tokens[currentIndex].value);
        }
        if ( errorOut)
        {
            ParseException pe=new ParseException( this);
            reset();
            throw pe;
        }
        return previousSet;
    }

    public void setLine( String toParse)
    {
        tokens=tokenize( toParse);
    }

    // Bean type interface for accessing stored value names
    public String[] getStoredValues()
    {
        return (String[])storedValues.keySet().toArray( new String[0]);
    }

    public void addStoredValuesListener( PropertyChangeListener l)
    {
        storedValuesSupport.addPropertyChangeListener( "storedValues", l);
    }

    public void removeStoredValuesListener( PropertyChangeListener l)
    {
        storedValuesSupport.removePropertyChangeListener( l);
    }

    // Package interface
    Token[] tokens;
    int currentIndex;
    SetExpression previousSet;
    HashMap storedValues; // String, SetExpression
    PropertyChangeSupport storedValuesSupport;

    static class Token
    {
        public Symbol symbol;
        public String value;

        public Token( Symbol sym, String val)
        {
            symbol=sym;
            value=val;
        }

        public String toString()
        {
            return value;
        }
    }

    static Symbol literalString=Symbol.get( "_literalString");
    static Symbol nameSymbol=Symbol.get( "_nameSymbol");

    static class ReservedWord extends Symbol
    {
        static Hashtable wordList=new Hashtable();
        protected ReservedWord( String w)
                throws Symbol.DuplicateSymbolException
        {
            super( w);
            wordList.put( w, this);
        }

        static ReservedWord getReserved( String w)
        {
            try
            {
                return new ReservedWord( w);
            }
            catch ( Symbol.DuplicateSymbolException dse)
            {
                return (ReservedWord)dse.duplicate;
            }
        }
    }

    static class LiteralToken extends Token
    {
        LiteralToken( String val)
        {
            super( literalString, val);
        }

        public String toString()
        {
            return "\""+value+"\"";
        }
    }

    static Token[] tokenize( String toTokenize)
    {
        char[] chars=toTokenize.toCharArray();
        Vector tokens=new Vector();
        StringBuffer currentString=new StringBuffer();
        int i=0;
        boolean inQuoted=false;
        for ( ; i<=chars.length; i++)
        {
            char c;
            if ( i==chars.length)
            {
                if ( inQuoted)
                    c='"';
                else
                    c='\n';
            }
            else
            {
                c=chars[i];
            }
            if ( inQuoted)
            {
                if ( c=='"')
                {
                    tokens.addElement( new LiteralToken( currentString.toString()));
                    currentString.setLength(0);
                    inQuoted=false;
                }
                else
                    currentString.append( c);
            }
            else
            {
                switch ( c)
                {
                case ' ' :
                case '\r' :
                case '\n' :
                case '\t' :
                case '"' :
                    if ( currentString.length()>0)
                    {
                        String cs=currentString.toString().toLowerCase();
                        currentString.setLength(0);
                        ReservedWord rw=(ReservedWord)ReservedWord.wordList.get( cs);
                        if ( rw==null)
                        {
                            tokens.addElement( new Token( nameSymbol, cs));
                        }
                        else
                        {
                            tokens.addElement( new Token( rw, cs));
                        }
                    }
                    if ( c=='"')
                    {
                        inQuoted=true;
                    }
                    break;

                default :
                    currentString.append( c);
                }
            }
        }
        tokens.addElement( new Token( finalToken, ";"));
        tokens.addElement( new Token( Parser._end_, ""));

        Token[] retval=new Token[tokens.size()];
        tokens.copyInto( retval);
        return retval;
    }

    void pushCastToken( SetExpression se)
    {
        Token castToken;
        if ( se instanceof ClassSet)
            castToken=new Token( classcast, "");            
        else if ( se instanceof MethodSet)
            castToken=new Token( methodcast, "");            
        else if ( se instanceof CallSet)
            castToken=new Token( callcast, "");            
        else
            castToken=new Token( fieldcast, "");
        ArrayList tokenList=new ArrayList( tokens.length+1);
        for ( int i=0; i<tokens.length; i++)
        {
            if ( i==currentIndex)
            {
                tokenList.add( castToken);
            }
            tokenList.add( tokens[i]);
        }
        tokens=new Token[tokenList.size()];
        tokens=(Token[])tokenList.toArray( tokens);
        currentIndex--;
        clearNextValue();
    }

    public static interface SetExpression
    {
        public abstract Enumeration execute( AnalyzerDB db)
            throws Exception;
    }

    static interface CallSet extends SetExpression
    {
    }

    static interface ClassSet extends SetExpression
    {
    }

    static interface MethodSet extends SetExpression
    {
    }

    static interface FieldSet extends SetExpression
    {
    }

    static interface FieldReferenceSet extends SetExpression
    {
    }

    static class CallsTo implements CallSet
    {
        private MethodSet _methods;

        CallsTo( MethodSet methods)
        {
            _methods=methods;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return new BiEnumeration( _methods.execute( db)) {
                protected Enumeration getNextCurrent( Object next)
                {
                    return ((DBMethod)next).getCalledBy();
                }
            };
        }
    }

    /*
     ClassSet : Class "x"
              | All Classes
              | Base Classes of ClassSet
              | Recursive Base Classes of ClassSet
              | Derived From ClassSet
              | Recursive Derived From ClassSet
              | Class of MethodSet
              | ClassSet matching "x"
     */
    static class ClassGet implements ClassSet
    {
        private String _className;

        ClassGet( String className)
        {
            _className=className;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Vector tmp=new Vector( 1);
            Object q=db.findWithKey( "analyzer.DBClass", _className);
            if ( q!=null)
                tmp.addElement( q);
            return tmp.elements();
        }
    }

    static class ClassesGet implements ClassSet
    {
        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return db.getAll( "analyzer.DBClass");
        }
    }

    static class BaseClasses implements ClassSet
    {
        ClassSet _next;

        BaseClasses( ClassSet nextSet)
        {
            _next=nextSet;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Hashtable ht=new Hashtable();
            for ( Enumeration e=_next.execute( db); e.hasMoreElements();)
            {
                DBClass c=(DBClass)e.nextElement();
                Enumeration superEnum=c.getSuperClasses();
                while ( superEnum.hasMoreElements())
                {
                    DBClass superClass=(DBClass)superEnum.nextElement();
                    ht.put( superClass, superClass);
                }
            }
            return ht.keys();
        }
    }

    static class DerivedClasses implements ClassSet
    {
        ClassSet _next;

        DerivedClasses( ClassSet nextSet)
        {
            _next=nextSet;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Hashtable ht=new Hashtable();
            for ( Enumeration e=_next.execute( db); e.hasMoreElements();)
            {
                DBClass c=(DBClass)e.nextElement();
                Enumeration superEnum=c.getDerivedClasses();
                while ( superEnum.hasMoreElements())
                {
                    DBClass superClass=(DBClass)superEnum.nextElement();
                    ht.put( superClass, superClass);
                }
            }
            return ht.keys();
        }
    }

    static class RecursiveBaseClasses extends BaseClasses
    {
        RecursiveBaseClasses( ClassSet nextSet)
        {
            super( nextSet);
        }



        private static void addSuperClasses( DBClass current, Hashtable ht)
        {
            Enumeration superEnum=current.getSuperClasses();
            while ( superEnum.hasMoreElements())
            {
                DBClass superClass=(DBClass)superEnum.nextElement();
                if ( ht.get( superClass)==null)
                {
                    ht.put( superClass, superClass);
                    addSuperClasses( superClass, ht);
                }
            }
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Hashtable ht=new Hashtable();
            for ( Enumeration e=_next.execute( db); e.hasMoreElements();)
            {
                addSuperClasses( (DBClass)e.nextElement(), ht);
            }
            return ht.keys();
        }
    }

    static class RecursiveDerivedClasses extends BaseClasses
    {
        RecursiveDerivedClasses( ClassSet nextSet)
        {
            super( nextSet);
        }

        private static void addSuperClasses( DBClass current, Hashtable ht)
        {
            Enumeration superEnum=current.getDerivedClasses();
            while ( superEnum.hasMoreElements())
            {
                DBClass superClass=(DBClass)superEnum.nextElement();
                if ( ht.get( superClass)==null)
                {
                    ht.put( superClass, superClass);
                    addSuperClasses( superClass, ht);
                }
            }
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Hashtable ht=new Hashtable();
            for ( Enumeration e=_next.execute( db); e.hasMoreElements();)
            {
                addSuperClasses( (DBClass)e.nextElement(), ht);
            }
            return ht.keys();
        }
    }

    static class ClassOfMethod implements ClassSet
    {
        private MethodSet _methodSet;
        ClassOfMethod( MethodSet nextSet)
        {
            _methodSet=nextSet;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            Hashtable ht=new Hashtable();
            for ( Enumeration e=_methodSet.execute( db);
                e.hasMoreElements();)
            {
                DBClass c=((DBMethod)e.nextElement()).getDBClass();
                ht.put( c, c);
            }
            return ht.keys();
        }
    }

    static class ClassMatching implements ClassSet
    {
        ClassSet _toFilter;
        String _filterString;

        ClassMatching( ClassSet toFilter, String filterString)
        {
            _toFilter=toFilter;
            _filterString=filterString;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return new FilterEnumeration( _toFilter.execute( db)) {
                protected Object filterObject( Object next)
                {
                    Object retVal=null;
                    if ( ((DBClass)next).getName().indexOf(
                        _filterString)!= -1)
                        retVal=next;
                    return retVal;
                }
            };
        }
    }

    static class SingleClass implements ClassSet
    {
        DBClass _class;

        SingleClass( DBClass c)
        {
            _class=c;
        }

        public Enumeration execute( AnalyzerDB db)
        {
            return enumFromObject( _class);
        }
    }

    /*
      MethodSet : methods in ClassSet
                | polymorphic MethodSet
                | matching "x" MethodSet
                | uncalled MethodSet
                | uncalled polymorphic MethodSet
     */
     static class MethodsIn implements MethodSet
    {
        private ClassSet _classSet;
        MethodsIn( ClassSet classes)
        {
            _classSet=classes;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return new BiEnumeration( _classSet.execute( db)) {
                protected Enumeration getNextCurrent( Object nextBase)
                {
                    return ((DBClass)nextBase).getMethods();
                }
            };
        }
    }

    static class Polymorphic implements MethodSet
    {
        MethodSet _methods;

        Polymorphic( MethodSet methods) {
            _methods=methods;
        }

        public Enumeration execute( final AnalyzerDB db)
            throws Exception
        {
            return new PolyEnumeration( db, _methods.execute( db));
        }

        /* Can't be a local class due to compiler bug --
         * can't find superclass [blank] of local class */
        static class PolyEnumeration extends BiEnumeration
        {
            DBMethod soughtMethod;
            AnalyzerDB db;

            PolyEnumeration( AnalyzerDB adb, Enumeration methods)
            {
                super( methods);
                db=adb;
            }

            protected Enumeration getNextCurrent( Object next)
            {
                soughtMethod=(DBMethod)next;
                DBClass c=soughtMethod.getDBClass();
                try
                {
                    Enumeration fromBase=new FilterEnumeration( 
                        ( new RecursiveBaseClasses( new
                            SingleClass( c))).execute( db)) {
                        protected Object filterObject( Object base)
                        {
                            DBClass filterc=(DBClass)base;
                            try
                            {
                            return db.findWithKey( "analyzer.DBMethod",
                                DBMethod.makeKey( filterc.getName(),
                                soughtMethod.getName(),
                                soughtMethod.getSignature()));
                            }
                            catch ( Exception e)
                            {
                                throw new NoSuchElementException(
                                    e.getMessage());
                            }
                        }
                    };
                Enumeration fromDerived=new GoodBase( c, db);
                return new ComboEnumeration( enumFromObject(
                    soughtMethod), new ComboEnumeration( fromBase,
                    fromDerived));
                }
                catch ( Exception e)
                {
                    throw new NoSuchElementException( e.getMessage());
                }
            }

            class GoodBase extends BiEnumeration {
                AnalyzerDB _adb;
                GoodBase( DBClass fromHere, AnalyzerDB adb)
                    throws Exception
                {
                    super( ( new DerivedClasses( new
                        SingleClass( fromHere))).
                        execute( adb));
                    _adb=adb;
                }

                protected Enumeration getNextCurrent(
                    Object base)
                {
                    DBClass c=(DBClass)base;
                    try
                    {
                        DBMethod candidate=(DBMethod)
                            _adb.findWithKey( "analyzer.DBMethod",
                            DBMethod.makeKey( c.getName(),
                            soughtMethod.getName(),
                            soughtMethod.getSignature()));
                        if ( candidate==null || !
                            ( candidate.methodStatus()==
                            DBMethod.REAL))
                        {
                            return candidate==null ?
                                (Enumeration)new GoodBase( c, _adb) :
                                (Enumeration)new ComboEnumeration(
                                enumFromObject( candidate),
                                new GoodBase( c, _adb));
                        }
                        else
                        {
                            return DBMethod.emptyVector.elements();
                        }
                    }
                    catch ( Exception e)
                    {
                        throw new NoSuchElementException(
                            e.getMessage());
                    }
                }
            }
        }
   }

    static class MethodMatching implements MethodSet
    {
        MethodSet _toFilter;
        String _filterString;

        MethodMatching( MethodSet toFilter, String filterString)
        {
            _toFilter=toFilter;
            _filterString=filterString;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return new FilterEnumeration( _toFilter.execute( db)) {
                protected Object filterObject( Object next)
                {
                    Object retVal=null;
                    if ( ((DBMethod)next).getName().indexOf(
                        _filterString)!= -1)
                        retVal=next;
                    return retVal;
                }
            };
        }
    }

    static class UncalledMethod implements MethodSet
    {
        protected MethodSet _toFilter;

        UncalledMethod( MethodSet toFilter)
        {
            _toFilter=toFilter;
        }

        public Enumeration execute( AnalyzerDB db)
            throws Exception
        {
            return new FilterEnumeration( _toFilter.execute( db)) {
                protected Object filterObject( Object next)
                {
                    DBMethod method=(DBMethod)next;
                    if ( method.getCalledBy().hasMoreElements())
                        method=null;
                    return method;
                }
            };
        }

        static class UncalledPolymorphic extends UncalledMethod
        {
            UncalledPolymorphic( MethodSet toFilter)
            {
                super( toFilter);
            }

            public Enumeration execute( final AnalyzerDB db)
                throws Exception
            {
                return new FilterEnumeration( _toFilter.execute(db)) {
                    protected Object filterObject( Object next)
                    {
                        DBMethod method=(DBMethod)next;
                        try
                        {
                            for ( Enumeration e=(new Polymorphic( new SingleMethod( method))).execute( db); e.hasMoreElements() && method!=null;)
                            {
                                if ( ((DBMethod)e.nextElement()).
                                    getCalledBy().hasMoreElements())
                                    method=null;
                            }
                        }
                        catch ( Exception e)
                        {
                        }
                        return method;
                    }
                };
            }
        }
    }

    static class SingleMethod implements MethodSet
    {
        DBMethod _method;

        SingleMethod( DBMethod c)
        {
            _method=c;
        }

        public Enumeration execute( AnalyzerDB db)
        {
            return enumFromObject( _method);
        }
    }

    static public class ComboEnumeration extends BiEnumeration
    {
        private static Enumeration combined( Enumeration e1,
            Enumeration e2)
        {
            Vector tmp=new Vector( 2);
            tmp.addElement( e1);
            tmp.addElement( e2);
            return tmp.elements();
        }

        ComboEnumeration( Enumeration e1, Enumeration e2)
        {
            super( combined( e1, e2));
        }

        protected Enumeration getNextCurrent( Object base)
        {
            return (Enumeration)base;
        }
    }

    static public Enumeration enumFromObject( Object o1)
    {
if ( o1==null)
throw new IllegalStateException( "null passed to enumFromObject");
        Vector tmp=new Vector(1);
        tmp.addElement( o1);
        return tmp.elements();
    }

    static public abstract class FilterEnumeration implements Enumeration
    {
        private Enumeration _baseEnumeration;
        private Object next;
        // Kludge because of compiler bug
        private boolean initialized;

        public FilterEnumeration( Enumeration base)
        {
            _baseEnumeration=base;
            // Kludge because of compiler bug
            initialized=false;
        }

        abstract protected Object filterObject( Object next);

        private void getNextObject()
        {
            for ( next=null; next==null &&
                _baseEnumeration.hasMoreElements();)
            {
                next=filterObject( _baseEnumeration.nextElement());
            }
        }

        public boolean hasMoreElements()
        {
            // Kludge because of compiler bug
            if ( ! initialized)
            {
                getNextObject();
                initialized=true;
            }
            return next!=null;
        }

        public Object nextElement()
        {
            // Kludge because of compiler bug
            if ( ! initialized)
            {
                getNextObject();
                initialized=true;
            }
            if ( next==null)
                throw new NoSuchElementException();
            Object retVal=next;
            getNextObject();
            return retVal;
        }
    }

    static public abstract class BiEnumeration implements Enumeration
    {
        private Enumeration _baseEnumeration;
        private Enumeration _currentEnumeration;

        public BiEnumeration( Enumeration base)
        {
            _baseEnumeration=base;
            _currentEnumeration=null;
        }

        private void setCurrentEnumeration()
        {
            while (  _currentEnumeration==null
                || ! _currentEnumeration.hasMoreElements())
            {
                if ( _baseEnumeration.hasMoreElements())
                    _currentEnumeration=getNextCurrent( _baseEnumeration.nextElement());
                else
                {
                    _currentEnumeration=null;
                    break;
                }
            }
        }

        protected abstract Enumeration getNextCurrent( Object base);

        public boolean hasMoreElements()
        {
            setCurrentEnumeration();
            return _currentEnumeration!=null;
        }

        public Object nextElement()
        {
            setCurrentEnumeration();
            if ( _currentEnumeration==null)
            {
                throw new NoSuchElementException();
            }
            return _currentEnumeration.nextElement();
        }
    }

// Include output here

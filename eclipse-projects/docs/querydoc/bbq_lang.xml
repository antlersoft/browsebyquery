<!DOCTYPE book SYSTEM "docbookx.dtd" [
<!ENTITY p-bbq "BBQ">
]>
<book>
  <title>The Browse-By-Query Query Language, ver. 1.3 (Java/C#-CIL)</title>
  <bookinfo>
    <author>
      <firstname>Michael</firstname>
      <surname>MacDonald</surname>
      <affiliation>
        <orgname>antlersoft</orgname>
        <address>
          <email>mars@antlersoft.com</email>
        </address>
      </affiliation>
    </author>
  </bookinfo>
  <preface>
    <title>A Note on the Language</title>
    <para>This document describes the &p-bbq; language
for querying Java and C#/CIL systems.  The two query languages are
very similar; portions that are specific to one or the other platform
are noted with (Java) or (C#/CIL).</para>
	<para>The syntax of the query language is motivated by the desire
	to have queries (set expressions) in the language resemble the noun phrases in English
	that describe what the queries return.  Just as English adjectives and adjectival constructions
	precede the nouns they modify, &p-bbq; queries are built by prepending filters and transforms
	to simpler queries.
	</para>
	<para>The concepts of the underlying object query system are independent of this syntax,
	however.  The concepts are also quite distinct from those in SQL, since you work directly with
	&p-bbq;'s object model, rather than tabular abstractions based on it.
	&p-bbq; attempts to provide an intuitive facility for developers to envision and realize different aspects
	of their system's code base, backed by the features of a powerful and general object query system.
	One can imagine providing this facility with a completely different language syntax.
	</para>
  </preface>
  <chapter>
    <title>Overview</title>
    <para>
Modern integrated development environments include some sort of code browser; the browser
understands the elements and structure of your source code and presents that structure
in various ways to help you navigate your code base.
&p-bbq; has the same basic purpose: to help you find things in your code.
What &p-bbq; lets you do that a conventional
browser does not is specify just what you want to find
with as much precision and complexity as you desire; it
will then find just the spots in your code in which you're interested.
When you are developing a program, you have a mental model of what
will need to be changed next: &p-bbq; is intended to make it possible
to express that mental model and get a view of just those aspects
of your system in which you are interested.
The bigger the system, or the more unfamiliar with it you are,
the more valuable &p-bbq; will be.
</para>
<para>
    To make this possible for you, &p-bbq; introduces a new language, a
language specialized
for finding things in your code.
The assumption is that programmers are skilled at expressing complex ideas
by composing expressions--why not let them use this skill to more
effectively navigate their code base?
Most database programmers wouldn't dream of working without the
ability to compose <foreignphrase>ad hoc</foreignphrase> SQL
queries to show what is in the database.
Why shouldn't you use a similar facility to help
you work with the thousands
of classes, variables and methods in your system?
</para>
    <sect1>
      <title>Set Expressions</title>
<para>
The purpose of &p-bbq; is to easily find constructs in your code, any of the things &p-bbq; keeps track of: class definitions, method definitions, method calls, field references and more.
The language is intended to allow you to express what you are interested in,
if not in plain english, at least in a form that is reasonably close to
how you might think.
You write an expression, a <firstterm>set expression</firstterm>, that defines the set of program constructs you want to see.<footnote id="fn-regexp">
	<para>Those familiar with regular expressions may find that &p-bbq;
set expressions are analogous; instead of finding instances of matching
character strings, set expressions let you find instances of matching program
constructs.</para>
      </footnote>
&p-bbq; then finds all the parts of your code that match the
expression. Typically, &p-bbq; will have read your code (known as the <firstterm>analyzed system</firstterm>)
into an object-oriented database.
The set expression specifies a query on this database.
</para>
<para>
One of a few <firstterm><link linkend="r-simplesetexpressions">simple set expressions</link></firstterm> forms the basis
for any query.  These are simple noun phrases that describe
a set of program constructs: <userinput>all classes</userinput> represents
all the classes in your program; <userinput>class "java.util.ArrayList"</userinput> represents a single class.</para>
<para>
You go from the simple set expressions to the exact set expression you want
by applying modifiers to the simple expression.
&p-bbq; has a library of built-in modifiers--<firstterm>transforms</firstterm>
and <firstterm>filters</firstterm><footnote><para>
	 This terminology is generic and might be confusing to those familiar
with Unix shell programming, since a &p-bbq; transform
is in fact comparable to a Unix filter command,
while a &p-bbq; filter is more specialized.</para>
	</footnote>--that represent the relationships between
program objects.  Using these modifiers
in the set expression tells &p-bbq; how to follow these relationships
to retrieve the desired results.
</para>
</sect1>
<sect1>
<title>Transforms</title>
<para>
In general, a transform changes the result of a set expression into another set;
this is a very flexible concept,
and you can do all sorts of processing with transforms.
You apply a transform to a set expression just by writing the transform
in front of the expression;
the result is a new set expression that returns the result of
the original set expression transformed.
</para>
<para>
A commonly used transform is <userinput>methods in</userinput>,
which reflects one relationship between methods and classes: methods
are defined within classes.
You apply this transform to a set expression that represents
a set of classes,
and the resulting set expression represents the
methods that are defined in those classes.
So the set expression <userinput>methods in class "java.util.ArrayList"</userinput>
returns, well, just what you'd expect.
</para>
<para>
The language provides a selection of built-in transforms that
reflect the relationships
among the program objects in the &p-bbq; database; they're listed in the <link linkend="r-transforms">reference</link>.
You'll often combine these transforms in a series to get the results you want.
For example <userinput>calls to</userinput>
is a transform that takes a set of methods and is often used
with the <userinput>methods in</userinput> transform;
the set expression <userinput>calls to methods in class "java.util.ArrayList</userinput>
returns all the calls, from anywhere in the analyzed system,
to methods in the ArrayList class.
A series of transforms can be regarded as a single transform
that combines their effects: <userinput>( calls to methods in )</userinput>
is a transform that turns a set expression representing a set of classes
into a set expression for all the calls
to any methods defined in those classes.
</para>
<para>
You might think that putting the transform in front of the set expression is
confusing.  The rationale is this: a set expression should read like
a noun phrase in English, and filters and transforms, like adjectives,
precede the things they modify.
When you read a set expression, you can picture the data flowing
from the simple set expression through the transforms from right to left.
</para>
<sect2 id="r-stateless">
<title>Stateless Transforms</title>
<para>
In general, all the results of a transform may depend on any of the elements
in the set being transformed.
However, some transforms have the property of being <firstterm>stateless</firstterm>.
These transforms will return the same result for any given transformed object,
regardless of the other elements in the set to be transformed.
Because of this, stateless transforms behave more predictably in the context
of some transform operators such as <link linkend="r-exists">exists</link>
and <link linkend="r-recursive">recursive</link>.
If a transform is stateless, that is noted in the synopsis for the transform in the <link linkend="r-transforms">reference</link>.
</para>
<para>
Many operators that were stateless transforms in previous releases of the language are now
implemented as
<link linkend="r-value-expressions">value expressions</link>.
You can still use them in set expressions with the same syntax; you can also use them
as part of value expressions.
</para>
</sect2>
</sect1>
<sect1 id="r-filters-intro">
<title>Filters</title>
<para>
A filter is a special kind of transform which changes the
set only by excluding some of its members.
One common filter might be <userinput>public</userinput>,
which can be applied to a set expression that returns
classes, methods, or fields and keeps only
those that are declared public.  So again, the set expression
<userinput>public methods in class "java.util.ArrayList"</userinput>
will return just what it says.
The language implements many filters, described in the
<link linkend="r-filters">reference</link>.
</para>
<para>
Filters represent a boolean condition, and so you can combine them
with boolean operators (not, and, or, xor) to create a more complex filter.
<userinput>( public or protected ) methods in class "java.util.ArrayList"</userinput>
will give the list of all the methods in the class that are visible outside
its package.
</para>
<para>
By definition, the transform represented by a filter is <link linkend="r-stateless">stateless</link>.
</para>
</sect1>
      <sect1>
	<title>Set Operators</title>
	<para>As you might expect from a language that deals with
set expressions, &p-bbq; uses set operators: union, intersection,
deintersection, without.
You can use these operators to combine two set expressions.
An equivalent expression to the previous example could be written
<userinput>( public methods in class "java.util.ArrayList" ) union
( private methods in class "java.util.ArrayList" )</userinput>.
</para>
<para>
What may be less obvious is that set expressions can also be used
to combine transforms.  A commonly used transform that can be
applied to classes
is <userinput>( calls to methods in ) union ( references to fields
in )</userinput>.  The union of two transforms applied to a set expression Foo
is equivalent to the union of the two set expressions that would
be obtained by applying each transform to Foo; the
same goes for the other set operators.
As you become
experienced with &p-bbq;,
you will much more commonly use the set operators
with transforms than with set expressions, because the
resulting set expressions are more compact with less duplication:
You would prefer
<userinput>( calls to methods in ) union ( references to fields in )
class "java.util.ArrayList"</userinput>
to
<userinput>( calls to methods in class "java.util.ArrayList" )
union ( references to fields in class "java.util.ArrayList" )
</userinput>
</para>
      </sect1>
      <sect1>
	<title>Types</title>
<para>
We've discussed filters and transforms as applying to specific
kinds of set expressions: those returning classes, or those
returning methods.
This concept is expressed more formally in the language
with <firstterm>expression types</firstterm>.
A set expression has a type, which represents the type of objects that
the expression returns (this type is distinct from any type within the
analyzed system.)
&p-bbq; supports a hierarchy of types that is fully described in the
<link linkend="r-types">reference</link>:
it includes: classes, methods, fields, method calls, field references, types (Java types), arguments,
packages,
and strings and numbers in expressions.
</para>
<para>
Most transforms can only be applied to certain types:
for example, <userinput>methods in</userinput>
can only be applied to a set expression with type <link linkend="r-type-class">class</link>, and the resulting expression
has type <link linkend="r-type-method">method</link>.
The reference page for each transform lists the types to which the transform
may be applied, as well as the type that will result from applying
the transform.
</para>
<para>
Similarly, most filters may only be applied to certain types,
which are listed on the reference page for the filter.
From the definition of filters you can see
that the output type of a filter is always identical
to its input type.
</para>
<para>
When you combine two set expressions with an operator,
the resulting expression is assigned the most specific type
that is a base type of both the constituent expressions.
Similarly, &p-bbq; has rules for determining the applicable
and result types of
complex transforms and filters.
You probably don't need to know the details of the rules, but
&p-bbq; uses them to determine if the expressions you
write make sense.
For example, the transform
<userinput>calls to intersection fields in</userinput>
can't work
because it
is combining the two transforms
<userinput>calls to</userinput>
and <userinput>fields in</userinput>;the <userinput>calls to</userinput>
transform applies to methods
while the <userinput>fields in</userinput>
transform applies only to classes.
There is no set expression type
to which both transforms could sensibly be applied.
If you are using &p-bbq; and receive an error message
about <errorname>Incompatible types</errorname>,
you've probably made this type of mistake in
writing your set expression.
The complete type resolution rules are listed in the
<link linkend="r-types">reference</link>.
</para>
    </sect1>
<sect1 id="r-value-expression-intro">
<title>Value Expressions</title>
<para>
Set expressions are powerful and general,
but because of their generality
it can be difficult for the language to know enough
about them to combine them in interesting ways.
Therefore, &p-bbq; has special support for a particular
subset known as <firstterm>value expressions</firstterm>,
which are guaranteed to result in a single value--rather than a set--when
evaluated within a particular context.
In &p-bbq;, constants are value expressions,
some operators (i.e. <link linkend="r-count"><userinput>count</userinput></link>, <userinput>&amp;</userinput>) produce value expressions,
and <link linkend="r-value-operators">value operators</link> can only be used with value expression.
Value expressions, in turn, can be used as part of set expressions or transforms.
</para>
<para>
There are three ways that value expressions can be used to produce a value
within set expressions: they can have a value independent of the rest of the expression;
they can have a value for each member of a set to which they are applied;
or they can have a single value when applied to a set as a whole.
More formally, each of these ways to evaluate
a value expression is referred to as a <firstterm>value context</firstterm>.
Most value expressions are only meaningful in one of the contexts.
We'll provide a more complete definition of each of the contexts mentions above:</para>
<variablelist>
	<varlistentry>
		<term>Scalar Context</term>
		<listitem>
			<para>In a scalar context, a value expression is evaluated without reference
			to any other objects or expressions.  A constant is an example of a value expression that may
			be evaluated in a scalar context.
			</para>
			<para>
			If a value expression may be evaluated in a scalar context, it also can be used as a complete
			set expression.
			</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Count-Preserving Context</term>
		<listitem>
			<para>A value expression in a count-preserving context results in a single
			value when evaluated for a single object.</para>
			<para>When evaluated in a set expression, a count-preserving value expression
			functions as a stateless transform.</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Group Context</term>
		<listitem>
			<para>A value expression in a group context results in a single value
			when evaluated for an entire set.  The canonical example is the <link linkend="r-count">count</link>
			expression, which returns the number of members in a set.</para>
		</listitem>
	</varlistentry>
</variablelist>
<para>
Value expressions of the same context can be freely combined with the value operators to produce
a compound expression with that context.  Scalar expressions may be combined with count-preserving
expressions to produce another count-preserving expression, and scalar expressions may be
combined with group expressions to produce another group expression.  You can't combine
a group expression and a count-preserving expression to get a value expression.
</para>
<para>
Value expressions have a result type,
and non-scalar value expressions have a type to which they apply.
Combining value expressions with value operators is subject
to the same type resolution rules applicable to sets and transforms.
</para>
	<sect2>
		<title>Relational Operators and Value Expressions</title>
		<para>
		&p-bbq; supports comparing value expressions with the full set of relational operators
		(<userinput>&lt; &lt;= = != >= ></userinput>).  The result of such a comparison
		is a <link linkend="r-filters-intro">filter</link> applied
		to the expression that produced the value expressions.
		</para>
		<para>
		The <userinput>=</userinput> and <userinput>!=</userinput>
		operators apply to all types;
		the other relational operators only apply to the types with a pre-defined ordering,
		<link linkend="r-type-integer">integer</link> and
		<link linkend="r-type-string">string</link>.
		Therefore these other operators are most likely to be useful in conjunction
		with the <userinput><link linkend="r-count">count</link></userinput> expression.
		For example, to find all the methods in the analyzed system with more than
		3 arguments, you might use the following set expression:
		</para>
		<informalexample>
		<programlisting>( count of ( arguments of ) &gt; 3 ) methods in all classes</programlisting>
		</informalexample>
		<para>
		Note how in this example the relational operator expression that acts as a filter
		is enclosed in parentheses because the relational operators have lower precedence than the
		default rule, which is to apply transforms and value expressions to the following set expression.
		</para>
	</sect2>
</sect1>
    </chapter>
    <chapter id="r-tutorial-examples">
    	<title>Tutorial Examples</title>
    	<para>Now that you've had the birds-eye view of &p-bbq;, you may
    	be looking for examples that illustrate how the pieces fit together.
    	We'll examine in detail some queries that perform tasks which I hope
    	are both recognizable as the sort of tasks you might face, and also complex
    	enough to show how the power
    	of &p-bbq; can be useful.</para>
    	<sect1>
    		<title>Basic Queries</title>
    		<para>
    		To warm up, we'll write some queries that perform basic browsing functionality
    		that is already available in most IDE's.  If you're familiar at all with your IDE,
    		it's probably easier just to click on an object in the explorer and select
    		the right menu item than to type in these queries, but they will illustrate
    		the principles of &p-bbq;, and you always have the ability to build on them
    		to meet your specialized needs.
    		</para>
    		<para>
    		First, let's find the set of all calls to a particular method.
    		In this example we'll find the calls to the <userinput>iterator</userinput>
    		method in <userinput>java.util.ArrayList</userinput>.
    		You start with the <link linkend="r-calls-to"><userinput>calls to</userinput></link>
    		transform; that returns the result you want.  <userinput>calls to</userinput>
    		applies to a set of methods; so you next want to specify the method.
    		In &p-bbq; you normally pick a specific method (or field) by applying the <link linkend="r-matching">
    		<userinput>matching</userinput></link> filter with the name of the method to
    		the set of methods in a class.  You pick a particular class with the
    		<link linkend="r-class"><userinput>class</userinput></link> simple set expression.
    		So the complete query is:
    		</para>
    		<informalexample>
    			<programlisting>calls to matching "iterator" methods in class "java.util.ArrayList"</programlisting>
    		</informalexample>
    		<para>
    		Finding references to fields is very similar:
    		</para>
    		<informalexample>
    			<programlisting>references to matching "gridx" fields in class "java.awt.GridBagConstraints"</programlisting>
    		</informalexample>
    		<para>
    		If you don't want to type the complete path of the class, you can use the <link linkend="r-import">
    		<userinput>import</userinput></link> expression to set
    		packages to search automatically.
    		</para>
    		<informalexample>
    			<programlisting>import "java.awt"</programlisting>
    		</informalexample>
    		<para>
    		Then you can write the same query:
    		</para>
    		<informalexample>
    			<programlisting>references to matching "gridx" fields in class "GridBagConstraints"</programlisting>
    		</informalexample>
    		<para>
    		In the examples so far, we've been querying the simple set expression <userinput><link linkend="r-class">class</link></userinput>.
    		This is probably the one you will use most often, since it quickly sets the scope of the search to be
    		a particular class.
    		You can also do a more comprehensive search against <userinput><link linkend="r-all-classes">all classes</link></userinput>.
    		or within a <userinput><link linkend="r-package">package</link></userinput>.
    		For example, to find all the classes with "List" in their name in "java.util", you would use:
    		</para>
    		<informalexample>
    			<programlisting>matching "List" classes in package "java.util"</programlisting>
    		</informalexample>
    		<para>You can use <userinput><link linkend="r-all-classes">all classes</link></userinput>
    		or <userinput><link linkend="r-all-packages">all packages</link></userinput> when you
    		want to search through the entire analyzed system, but your query will take a little longer (or a lot longer)
    		to run.  In some cases, this might be exactly what you need: suppose you remember
    		part of a method name, but can't remember what class it's in.  &p-bbq; let's you
    		do the search more conveniently than a string-matching search through your source
    		files, because &p-bbq; knows what a method name is.
    		</para>
    		<informalexample>
    			<programlisting>matching "scape" methods in all classes</programlisting>
    		</informalexample>
    		<para>
    		Similarly, &p-bbq; knows when a sequence of characters in your code is part
    		of a string constant;
    		there are a couple of simple set expressions just for searching string constants.
    		You can look for references to a
    		particular string:
    		</para>
    		<informalexample>
    			<programlisting>references to string "import"</programlisting>
    		</informalexample>
    		<para>
    		You can also look for all string constants in the analyzed system that contain a certain sub-string:
    		</para>
    		<informalexample>
    			<programlisting>references to matching "import" all strings</programlisting>
    		</informalexample>
    		<para>
    		When you look for "all references to" something in any code browser,
    		you will often get a lot of irrelevant results.
    		You'll then look through the returned items one by one to find those you are actually
    		interested in.
    		If you have a good idea of the filtering you will do when you look through the browser results,
    		why not make this part of the query and have the browser do the work?
    		With &p-bbq; you can do this; you can use set operators or the <userinput><link linkend="r-exists">exists</link></userinput>
    		filter to search for calls to method <userinput>foo</userinput>
    		only from methods that also contain calls to method <userinput>bar</userinput>.
    		</para>
    		<informalexample>
    			<programlisting>( methods containing calls to matching "foo" methods in class "Sample" ) intersection ( methods containing calls to matching "bar" methods in class "Sample" )</programlisting>
    		</informalexample>
    		<para>
    		You now have some experience with the <link linkend="r-simplesetexpressions">simple set expressions</link>
    		and a few of the <link linkend="r-transforms">transforms</link>,
    		and you can compose searches of the &p-bbq; database equivalent
    		to, and beyond, the browser functions of your IDE.
    		These searches can serve as the foundation for the more sophisticated queries
    		where &p-bbq; really shines.
    		</para>
    	</sect1>
    	<sect1>
    		<title>A More Complex Example: Serializable Classes Missing <varname>serialVersionUID</varname></title>
    		<para>
    		When you need to, you can combine simple search elements in a variety of ways with &p-bbq;.
    		We'll examine how one particular search is constructed from simpler elements in some
    		detail.  Although it might seem daunting at first, the hope is that with familiarity
    		constructing similar queries will become almost effortless, second-nature.  Eventually you may come
    		to see more and more development tasks in terms of &p-bbq; queries.
    		</para>
	    	<para>
	    	If you have a class that implements <classname>java.io.Serializable</classname>,
	    	it's a good idea to to have the class include a version identifier in the form
	    	of a static long field named <varname>serialVersionUID</varname>.  This 
	    	query will identify such classes.</para>
	    	<para>First, let's find the classes that implement <classname>java.io.Serializable</classname>.
	    	Start with the <link linkend="r-class"><userinput>class</userinput></link> set expression,
	    	and apply the <link linkend="r-recursive-derived-classes"><userinput>recursive derived classes of</userinput></link>
	    	transform.
	    	</para>
	   		<informalexample>
    			<programlisting>recursive derived classes of class "java.io.Serializable"</programlisting>
    		</informalexample>
	    	<para>
	    	Now, we'll refine the query to include only those classes that <emphasis>do not</emphasis>
	    	have the version marker.
	    	"Does not have" in &p-bbq; generally translates to the <link linkend="r-exists"><userinput>exists</userinput></link>
	    	filter modified by the <link linkend="r-operators"><userinput>not</userinput></link>
	    	operator; <link linkend="r-exists"><userinput>exists</userinput></link> takes a transform argument
	    	that should produce whatever we are testing the existence of.
	    	In this case we are testing for a field with a certain name; we'll specify the name
	    	with the <link linkend="r-matching"><userinput>matching</userinput></link> filter.
	    	So the transform that finds the appropriate field in the class is:
	    	</para>
	    	<informalexample>
	    		<programlisting>matching "serialVersionUID" fields in<lineannotation> ...</lineannotation></programlisting>
	    	</informalexample>
	    	<para>
	    	We use that transform with the <link linkend="r-exists"><userinput>exists</userinput></link> filter
	     	to get the more specific set expression:
		   	</para>
	    	<informalexample>
	    		<programlisting>not exists ( matching "serialVersionUID" fields in ) recursive derived classes of class "java.io.Serializable"</programlisting>
	    	</informalexample>
	    	<para>
	    	Straightforward enough, I hope, and in fact the Eclipse IDE duplicates this
	    	functionality and by default will flag such classes in
	    	your project.
	    	</para>
	    	<para>
	    	The problem with the output of the query as written is that it might return a number of classes
	    	that are serializable only incidentally; for these classes you don't care if there is a <varname>serialVersionUID</varname>
	    	field.  For example (making some quick use to the <link linkend="r-count"><userinput>count</userinput></link>
	    	expression) the Eclipse 3.1 code base has 368 <classname>Serializable</classname> classes; only 169 of these
	    	have a serialVersionUID field.   Presumably, for the remaining 199 classes, it's not that important.
	    	One of the advantages of &p-bbq; is that it lets you focus quickly on what you <emphasis>do</emphasis>
	    	think is important.  Suppose you were not interested in all classes that implement <classname>Serializable</classname>,
	    	but only those that are derived from <classname>Persistent</classname>.
	    	You can readily modify the query and get exactly the list of classes that you want:
	    	</para>
	    	<informalexample>
	    		<programlisting>not exists ( matching "serialVersionUID" fields in ) recursive derived classes of class "Persistent"</programlisting>
	    	</informalexample>
	    	<para>
	    	Alternatively, you might be interested in any <classname>Serializable</classname> class within a certain package tree.
	    	You can do that by applying the transform that looks for the missing field
	    	</para>
	    	<informalexample>
	    		<programlisting>not exists ( matching "serialVersionUID" fields in )<lineannotation> ...</lineannotation></programlisting>
	    	</informalexample>
	    	<para>
	    	to the intersection	of the two sets of classes: classes derived from <classname>java.io.Serializable</classname>
	    	and classes within a package tree.
	    	</para>	    	
	    	<informalexample>
	    		<programlisting>recursive derived classes of class "java.io.Serializable" intersection classes in recursive ( packages in ) package "com.antlersoft"</programlisting>
	    	</informalexample>
	    	<para>
	    	When we construct the full expression we have to use parentheses to group the
	    	set expression because the intersection operator has low precedence:
	    	</para>
	    	<informalexample>
	    		<programlisting>not exists ( matching "serialVersionUID" fields in ) ( ( recursive derived classes of class "java.io.Serializable" ) intersection classes in recursive ( packages in ) package "com.antlersoft" )</programlisting>
	    	</informalexample>
	    	<para>
	    	When we deal with longer examples, it can help to use line breaks and indenting to see the structure of
	    	the query.
	    	A good rule is to break and indent at parentheses, and break lines before and after and back indent set
	    	operators.
	    	</para>
	    	<informalexample>
	    	<programlisting>
	    	not exists (
	    		matching "serialVersionUID" fields in
	    	)
	    	(
	    		(
	    			recursive derived classes of class "java.io.Serializable"
	    		)
	    	  intersection
	    		classes in recursive (
	    			packages in
	    		)
	    		package "com.antlersoft"
	    	)
	    	</programlisting>
	    	</informalexample>
	    </sect1>
    </chapter>
  <chapter>
    <title>Language Reference</title>
    <para>
The interpreter accepts requests and returns sets of objects.
A request contains one or more set expressions; if a request
contains multiple set expressions they are separated by
semi-colons [<userinput>;</userinput>].
The details of how the objects are returned
for each set expression depend on
the environment.
    </para>
    <sect1 id="r-language-elements">
      <title>Language Elements</title>
<para>A set expression consists of a sequence of tokens.
White space or punctuation delimits tokens.
A token may be punctuation, a constant, a name, or a reserved
word.
Names and reserved words consist of a string of alphanumeric
characters or underscores starting with a letter or underscore.
Reserved words will always start with a lower-case letter.
</para>
<para>
The only permissable punctuation within a set expression
are parentheses, which are used for grouping in set expressions,
filters or transforms; commas, which are used with certain
operators; the <link linkend="r-value-operators">value operators</link>,
and the regular expression matching operator <userinput>~</userinput>.  Punctuation tokens are recognized as tokens
in themselves and don't have to be set off with whitespace.</para>
<para>
There are two kinds of constants, integers and strings.
Integer constants are a string of decimal digits and must
specify a number between 0 and 2^32  -1 .
There are two types of string constants:
<itemizedlist>
<listitem><simpara>Quoted strings constants are enclosed in double quotation marks (");
double quotation marks or backslashes within the string
must be escaped by a backslash.</simpara>
</listitem>
<listitem>
<simpara>Slash-string constants are introduced with two forward slashes (//) and extend to the next
forward slash.  Forward slashes within the string may be escaped with a preceding backslash (\), but when backslashes
do not immediately precede forward slashes they are not treated specially.  This makes slash-strings
convenient for regular expressions, where you might have to use a lot of backslashes, but slash-strings
have no special meaning and may be used interchangably with quoted strings.
</simpara>
</listitem>
</itemizedlist>
Certain operators (<link linkend="r-tilde">~</link>, <link linkend="r-relational-operators">~=</link>, <link linkend="r-substitute">substitute()</link>)
take regular expressions.  Regular expressions can be contained in either kind of string constant, and are Java regular expressions
as defined in <ulink url="https://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">the documentation
				for <userinput>java.util.regex.Pattern</userinput></ulink>.
</para>
<para>
A sequence of one or more reserved words represents a
set operator, a logical operator,
a simple set expression,
a filter or a transform.
</para>
<para>
Names are words that must not conflict
with any of the reserved words, and must reference
an expression or transform previously defined with the <link linkend="r-setcommand">set command</link>.</para>
<para>
A valid set expression consists of one of the set expressions defined
in the language,
a name that had been defined as a set expression,
a scalar value expression,
a set expression with a transform prepended,
 two set expressions joined by one of the set operators,
or a set expression enclosed within parentheses.
</para>
<para>
A transform is one of the transforms defined by the language,
a name that has been defined as a transform,
a transform with another transform appended,
two transforms joined by one of the set operators,
a filter,
a count-preserving or group value expression,
or a transform enclosed within parentheses.
</para>
<para>
A filter is one of the filters defined in the language,
a filter with the reserved word <userinput>not</userinput> prepended,
two filters joined by the logical operators <userinput>and</userinput> or
 <userinput>or</userinput>,
two value expressions related by one of the relational operators,
or a filter enclosed within parentheses.
</para>
<para>
A value expression is a constant,
one of the value expression operators defined in the language,
two value expressions with compatible context combined with value operators,
or a value expression enclosed within parentheses.
</para>
<simpara>Reserved Words:</simpara>
      <simplelist columns="3">
	<member>abstract</member>
	<member>all</member>
	<member>arguments</member>
	<member>and</member>
	<member>annotated</member>
	<member>annotations</member>
	<member>any</member>
	<member>are</member>
	<member>array</member>
	<member>assembly <emphasis>C#</emphasis></member>
	<member>base</member>
	<member>bundles</member>
	<member>by</member>
	<member>called</member>
	<member>calls</member>
	<member>cast</member>
	<member>catches</member>
	<member>class</member>
	<member>classes</member>
	<member>containing</member>
	<member>count</member>
	<member>date</member>
	<member>deintersection</member>
	<member>deprecated  <emphasis>Java</emphasis></member>
<member>derived</member>
<member>each</member>
<member>execute</member>
<member>exists</member>
<member>fields</member>
<member>finalToken</member>
<member>first</member>
<member>from</member>
<member>import <emphasis>Java</emphasis></member>
<member>in</member>
<member>is</member>
<member>internal <emphasis>C#/CIL</emphasis></member>
<member>intersection</member>
<member>interface</member>
<member>matching</member>
<member>methodcast</member>
<member>methods</member>
<member>namespace <emphasis>C#/CIL</emphasis></member>
<member>namespaces <emphasis>C#/CIL</emphasis></member>
<member>not</member>
<member>or</member>
<member>of</member>
<member>package <emphasis>Java</emphasis></member>
<member>packages <emphasis>Java</emphasis></member>
<member>polymorphic</member>
<member>previous</member>
<member>protected</member>
<member>private</member>
<member>public</member>
<member>recursive</member>
<member>references</member>
<member>reference</member>
<member>referenced</member>
<member>resources</member>
<member>same</member>
<member>set</member>
<member>static</member>
<member>string</member>
<member>strings</member>
<member>substitute</member>
<member>that</member>
<member>to</member>
<member>type</member>
<member>types</member>
<member>uncalled</member>
<member>uncorrelated</member>
<member>union</member>
<member>unique</member>
<member>unset</member>
<member>using <emphasis>C#/CIL</emphasis></member>
<member>with</member>
<member>without</member>
<member>write</member>
<member>xor</member>
      </simplelist>
      <para>Reserved words all start with a lowercase letter.  Therefore, it is a convention of the language
      that user defined operators (for set expressions or transforms) start with an uppercase letter;
      this will distinguish them from current and future reserved words.
      </para>
    </sect1>
    <sect1 id="r-types">
      <title>Types</title>
      <para>&p-bbq; supports several data types, which are arranged
in a derivation hierarchy.
All types are derived, directly or indirectly,
from the base type <link linkend="r-type-object">object</link>.</para>
<mediaobject>
<imageobject>
<imagedata fileref="../image/bbq/TypeHierarchy.png"/>
</imageobject>
<textobject><phrase>(Diagram illustrating type hierarchy)</phrase></textobject>
</mediaobject>
<para>
Note that the type <link linkend="r-type-type">Type</link> represents
a type in Java (such as int, boolean, etc.) which is a completely different
than types within the query language.
</para>
<para>
Set expressions have a type, which is the most-derived common type
of all the objects in the resulting set.  Filters
and transforms may be applicable to only some types;
&p-bbq; determines the type of the expression
at every point of transform using these rules:
</para>
<para>
Combining expressions with set operators produces a compound expression;
if the two set expressions have different types than the type
of the compound expression is the most-derived type that is the
ancestor of both constituent types in the set expression.
</para>
<para>
Similarly, combining filters with a logical operator produces a compound
filter.
If the two filters are applicable to different types, the applicable
type for one of the filters must be derived from the applicable
type of the other filter,
and the applicable type of the compound filter is the most-derived
type.
</para>
<para>
When you combine two transforms with a set operator,
both kinds of type resolution may happen.
If the transforms have different applicable types,
one must derive from the other and the applicable type
of the compound transform is the most derived type.
If the transforms have different result types,
the result type of the compound transform is the most-derived
type that is an ancestor of each of the constituent result types.
</para>
      <refentry id="r-type-argument">
	<refnamediv>
	  <refname>argument</refname>
	  <refpurpose>Represents an argument to a method</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>Object with this type represent the arguments to a method.
	  Each argument has a <link linkend="r-type-type">type</link>,
	  and an ordinal, which represents the zero-based position of the argument
	  in the methods argument list (note that non-static, non-constructor
	  methods have an implicit argument-0 representing the this object).
	  If the information is available in the database, an argument
	  will also have a name, which is the name defined in the source
	  code.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
    <refentry id="r-type-annotation">
      <refnamediv>
      	<refname>annotation</refname>
      	<refpurpose>User-defined metadata</refpurpose>
      </refnamediv>
      <refsect1>
        <title>Parent</title>
        <para><link linkend="r-type-object">object</link></para>
      </refsect1>
      <refsect1>
        <title>Description</title>
        <para>An annotation object represents an instance of user-defined metadata associated with
        another object in the analyzed system: these are termed annotations in the Java world,
        and Attributes in .Net/C#.</para>
        <para>Each annotation has a <link linkend="r-type-class">class</link>, which is the class
        of the annotation object.  An annotation also has a reference to the object that is
        annotated, which may be a class, field, method or argument.</para>
      </refsect1>
    </refentry>
    <refentry id="r-type-assembly">
      <refnamediv>
      	<refname>assembly (C#/CIL)</refname>
      	<refpurpose>An assembly in the analyzed system</refpurpose>
      </refnamediv>
      <refsect1>
        <title>Parent</title>
        <para><link linkend="r-type-object">object</link></para>
      </refsect1>
    </refentry>
    <refentry id="r-type-bundle">
      <refnamediv>
      	<refname>resource bundle</refname>
      	<refpurpose>A collection of resources in the analyzed system</refpurpose>
      </refnamediv>
      <refsect1>
        <title>Parent</title>
        <para><link linkend="r-type-object">object</link></para>
      </refsect1>
      <refsect1>
        <title>Description</title>
        <para>A bundle represents a .properties file for Java, or a resource file in .Net/C#.
        A bundle has a name and contains a collection of <link linkend="r-type-string-resource">string resources</link>,
        which are name/value pairs.</para>
      </refsect1>
    </refentry>
      <refentry id="r-type-call">
	<refnamediv>
	  <refname>call</refname>
	  <refpurpose>Represents a method call</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-reference">reference</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-catch">
      	<refnamediv>
      	  <refname>catch</refname>
      	  <refpurpose>A catch of some exception type in a method</refpurpose>
      	</refnamediv>
      	<refsect1>
      	  <title>Parent</title>
      	  <para><link linkend="r-type-reference">reference</link></para>
      	</refsect1>
      </refentry>
      <refentry id="r-type-class">
	<refnamediv>
	  <refname>class</refname>
	  <refpurpose>Represents a Java class in the analyzed system</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>In &p-bbq; both Java classes and interfaces
	  are represented by this type.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-date">
	<refnamediv>
	  <refname>date</refname>
	  <refpurpose>Represents a date</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-field">
	<refnamediv>
	  <refname>field</refname>
	  <refpurpose>Represents a field in a Java class in the analyzed system</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-member">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-field-reference">
	<refnamediv>
	  <refname>field reference</refname>
	  <refpurpose>Represents a reference within a method to a field</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-reference">reference</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-integer">
	<refnamediv>
	  <refname>integer</refname>
	  <refpurpose>An integer numeric value</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-member">
		<refnamediv>
		  <refname>member</refname>
		  <refpurpose>A class member; a method or field</refpurpose>
		</refnamediv>
		<refsect1>
		  <title>Description</title>
		  <para>The common base class for methods and fields.</para>
		</refsect1>
		<refsect1>
		  <title>Parent</title>
		  <para><link linkend="r-type-object">Object</link></para>
		</refsect1>
      </refentry>
      <refentry id="r-type-method">
	<refnamediv>
	  <refname>method</refname>
	  <refpurpose>Represents a method in a class in the analyzed system</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>Note that all executable entities in classes in the analyzed system are considered
	  methods, including constructors and static initializers.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-object">
	<refnamediv>
	  <refname>object</refname>
	  <refpurpose>The root of the type tree</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>All other types are direct or indirect descendents of
this type.</para>
	</refsect1>
      </refentry>
      <refentry id="r-type-package">
	<refnamediv>
	  <refname>package (Java)/namespace (C#/CIL)</refname>
	  <refpurpose>Represents a java package or a namespace in C#/CIL</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-reference">
	<refnamediv>
	  <refname>reference</refname>
	  <refpurpose>Represents a reference to a program construct from within a Java class in the analyzed system</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-string">
	<refnamediv>
	  <refname>string</refname>
	  <refpurpose>A string value</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>Note that this represents the type of a string
	  within &p-bbq;, rather than a string that appears
	  within the analyzed system,
	  which is an instance of the <link linkend="r-type-string-constant">
	  string constant</link> type.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-string-constant">
	<refnamediv>
	  <refname>string constant</refname>
	  <refpurpose>Represents a string constant that appears in one or more classes in the analyzed system</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>
	  A string constant represents the string itself, rather than
	  any particular use of the string anywhere in the system
	  you are examining.  Use the
	  <userinput><link linkend="r-references-to">references to</link></userinput>
	  transform to get the actual references to the strings
	  returned by an expression of this type.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-string-constant-reference">
	<refnamediv>
	  <refname>string constant reference</refname>
	  <refpurpose>Represents a reference within a method to a string constant</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-reference">reference</link></para>
	</refsect1>
      </refentry>
      <refentry id="r-type-string-resource">
		<refnamediv>
		  <refname>string resource</refname>
		  <refpurpose>A named value representing a string, defined in a .properties or resource file</refpurpose>
		</refnamediv>
		<refsect1>
		  <title>Description</title>
		  <para>Each string resource found in the analyzed system has a name and a value.  There may be
		  many resources that have the same name.</para>
		  <para>
		  The name and value of each resource are stored in the database as <link linkend="r-type-string-constant">string constant</link>
		  objects, so you can search for these in the same collection as strings that are directly referenced in
		  the program's source.
		  </para>
		</refsect1>
		<refsect1>
		  <title>Parent</title>
		  <para><link linkend="r-type-object">Object</link></para>
		</refsect1>
      </refentry>
      <refentry id="r-type-type">
	<refnamediv>
	  <refname>type</refname>
	  <refpurpose>Represents a Java type</refpurpose>
	</refnamediv>
	<refsect1>
	  <title>Description</title>
	  <para>
	  These objects represent the type of a value in Java, which may be
	  one of the Java built-in types, an array type, or a Java class type.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Parent</title>
	  <para><link linkend="r-type-object">Object</link></para>
	</refsect1>
      </refentry>
    </sect1>
    <sect1 id="r-setexpressions">
      <title>Set Expressions</title>
      <para>&p-bbq; supplies <link linkend="r-simplesetexpressions">simple set expressions</link> that provide
the starting point for your queries, as well as some
<link linkend="r-commands"><firstterm>commands</firstterm></link>
which are set expressions that let you access
the interpreter's state.</para>
	<para>A &p-bbq; query is always a set expression.</para>
	</sect1>
    <sect1 id="r-simplesetexpressions">
      <title>Simple Set Expressions</title>
      <para>
      Simple set expressions define the set of objects that provides the initial scope of the query.
      You apply transforms and value expressions to the result of the simple set expression
      to traverse the object graph to retrieve the set of objects you want.
      </para>
      <para>
      Sometimes the simple set expression is just a constant.
      When you are searching from a particular type, the simple set is the name of the type as a string,
      and you apply the <userinput><link linkend="r-type">type</link></userinput>
      value expression to get the type object, and go from there.
      </para>
      <para>
      The other simple set expressions are listed in this section.
      </para>
      <refentry id="r-all-annotations">
		<refnamediv>
		  <refname>all annotations</refname>
		  <refpurpose>Returns all the annotations in the analyzed system</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		  <synopsis><userinput>all annotations</userinput></synopsis>
		</refsynopsisdiv>
		<refsect1>
		  <title>Description</title>
		  <para>
Returns the complete set of all annotations in the analyzed system; you can use this
expression as a starting point when you are doing a global search
of your system.
		  </para>
		</refsect1>
	    <refsect1>
	      <title>Type</title>
		  <para>
		  <link linkend="r-type-annotation">annotation</link>
		  </para>
		</refsect1>
      </refentry>
      <refentry id="r-all-classes">
	<refnamediv>
	  <refname>all classes</refname>
	  <refpurpose>Returns all classes in the analyzed system</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <synopsis><userinput>all classes</userinput></synopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
<para>
Returns the complete set of all classes in the analyzed system; you can use this
expression as a starting point when you are doing a global search
of your system.
</para>
	</refsect1>
	<refsect1>
	  <title>Type</title>
<para>
<link linkend="r-type-class">class</link>
</para>
	</refsect1>
      </refentry>
     <refentry id="r-all-packages">
	<refnamediv>
	  <refname>all packages</refname>
	  <refpurpose>Returns all the packages in the analyzed system</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <synopsis><userinput>all packages</userinput></synopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
<para>
Returns the complete set of all the java packages in the analyzed system; you can use this
expression as a starting point when you are doing a global search
of your system.
</para>
	</refsect1>
	<refsect1>
	  <title>Type</title>
<para>
<link linkend="r-type-package">package</link>
</para>
	</refsect1>
      </refentry>
	<refentry id="r-all-strings">
	  <refnamediv>
	    <refname>all strings</refname>
	    <refpurpose>Return all the string constants defined in the analyzed system</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>all strings</synopsis>
	    <synopsis>all string</synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>Returns all the string constants in the analyzed system.
You can use this as a starting point when you are doing a global
search through the string constants.</para>
	  </refsect1>
	  <refsect1>
	    <title>Type</title>
	    <para><link linkend="r-type-string-constant">string constant</link></para>
	  </refsect1>
	</refentry>
	<refentry id="r-class">
	  <refnamediv>
	    <refname>class "name"</refname>
	    <refpurpose>Select a single class by name</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>class <replaceable>name</replaceable></synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>Use this expression to get a single class; useful
when you are searching within one class.
<replaceable>name</replaceable> is a quoted string with the name of the class
as you would type it in a Java program; if you've use the import
command to set import paths, they will be prepended to the
name until a valid class is found.</para>
	  </refsect1>
	  <refsect1>
	    <title>Type</title>
	    <para><link linkend="r-type-class">Class</link></para>
	  </refsect1>
	</refentry>
	<refentry id="r-package">
	  <refnamediv>
	    <refname>package (Java)/namespace (C#/CIL)</refname>
	    <refpurpose>Select a single package/namespace by name</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>package <replaceable>name</replaceable></synopsis>
	    <synopsis>namespace <replaceable>name</replaceable></synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>Use this expression to get a single package or namespace; useful
when you are searching within one package.
<replaceable>name</replaceable> is a quoted string with the name of the package or namespace as you would type it
in the program.</para>
	  </refsect1>
	  <refsect1>
	    <title>Type</title>
	    <para><link linkend="r-type-package">package <emphasis>Java</emphasis>, namespace <emphasis>C#/CIL</emphasis></link></para>
	  </refsect1>
	</refentry>
	<refentry id="r-strings">
	  <refnamediv>
	    <refname>strings "string"</refname>
	    <refpurpose>Return a specific string constant</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>string <replaceable>string</replaceable></synopsis>
	    <synopsis>strings <replaceable>string</replaceable></synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>Returns the specific string constant
with the value <replaceable>string</replaceable>.  Use this
when you are looking for information about a specific
string constant.</para>
	  </refsect1>
	  <refsect1>
	    <title>Type</title>
	    <para><link linkend="r-type-string-constant">string constant</link></para>
	  </refsect1>
	</refentry>
	</sect1>
      <sect1 id="r-commands">
	<title>Commands and Miscellaneous Set Expressions</title>
	<para>The interpreter can remember set expressions you've run,
or the results of the set expressions, for you to use later
for your convenience or for faster querying.  These
special set expression commands let you work with the
interpreter's state.
</para>
	<refentry>
	  <refnamediv>
	    <refname>execute</refname>
	    <refpurpose>Convert a set expression to a set of objects</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>execute <replaceable>set expression</replaceable></synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>Sometimes you will end up needing the result of
a set expression multiple times.
If executing the set expression is resource intensive,
you might want to avoid evaluating it multiple times.
This operator executes a set expression once,
and stores the resulting set of objects; the resulting
set expression returns this set of objects.</para>
	    <para>This operator will commonly be used in conjunction with
the <link linkend="r-setcommand">set command</link>
to save the result of a time-consuming query for use in
later expressions.</para>
		  <refsect2>
		  	<title>Example</title>
		  	<para>
		  	This set command will save in the name DBClasses all classes with <literal>DB</literal> in their names.
		  	</para>
		  	<informalexample>
		  		<programlisting>set DBClasses to ~ //DB[^.]*\z/ all classes</programlisting>
		  	</informalexample>
		  	<para>You can then reference the set in other expressions without traversing the whole list of classes:</para>
		  	<informalexample>
		  		<programlisting>DBClasses intersection recursive derived classes of class "Persistent"</programlisting>
		  	</informalexample>
		  </refsect2>
</refsect1>
	</refentry>
	<refentry id="r-import">
	  <refnamediv>
	    <refname>import (Java)/using (C#/CIL)</refname>
	    <refpurpose>Set a list of packages or namespaces to search for classes</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <cmdsynopsis><command>import</command><arg choice="opt">set</arg><arg choice="opt" rep="repeat"><replaceable>string</replaceable></arg></cmdsynopsis>
	    <cmdsynopsis><command>using</command><arg choice="opt">set</arg><arg choice="opt" rep="repeat"><replaceable>string</replaceable></arg></cmdsynopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>You will commonly use the <link linkend="r-class"><userinput>class</userinput></link>
simple set expression as the foundation of your queries,
and it can become tiresome to type the complete class name each time.
You can use this command to specify a list of packages
to search for a named class.  Each supplied <replaceable>string</replaceable> is
a package name.  You can use the import command as many
times as you want to add additional packages to the list;
if you use the set keyword with the import command the
list is cleared before packages are added.</para>
<para>
The result of the command is the set of strings (packages) that are in the list.
</para>
<para>
Note that this command approximates a Java import statement only very roughly;
it does not actually interpret the strings you supply as package names;
it only preprends each in turn with a "." to the string you supply
when looking for a class object with the class set expression.
</para>
	  </refsect1>
	  <refsect1>
	    <title>Type</title>
	    <para><link linkend="r-type-string">string</link></para>
	  </refsect1>
	</refentry>
	<refentry>
	  <refnamediv>
	    <refname>previous</refname>
	    <refpurpose>Access the last set expression evaluated by
the interpreter</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <synopsis>previous</synopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
	    <para>
Use this reserved word anywhere a set expression is permitted, to
reference the last set expression evaluated by the interpreter. If there has been
no previous expression evaluated, a set expression representing the empty set
is substituted.
            </para>
	  </refsect1>
	</refentry>
	<refentry id="r-setcommand">
	  <refnamediv>
	    <refname>set</refname>
	    <refpurpose>Assign a name to a set expression or transform</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <cmdsynopsis><command>set</command><arg choice="plain"><replaceable>name</replaceable></arg><arg choice="plain">to</arg><arg choice="plain"><replaceable>set expression</replaceable></arg></cmdsynopsis>
	    <cmdsynopsis><command>set</command><arg choice="plain"><replaceable>name</replaceable></arg><arg choice="plain">to</arg><arg choice="plain"><replaceable>transform</replaceable></arg></cmdsynopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
		<para>Sometimes, you'll want to refer to a single set
		expression or transform again and again when constructing
		other set expressions.  This command lets you assign
		a name to a set expression or transform; you can then use
		the name in other expressions
		instead of writing out the whole transform or set expression
		over again.
		</para>
		<para>&p-bbq; uses the same name space for both set expressions and
		transforms; you can re-use a given name to give it a different
		meaning,
		but the name will only refer to either a set expression or a transform at
		any one time.
		Also, changing the meaning of a name does not change
		the meaning of any existing
		definitions that might have been made using the old
		definition of the name.
			<itemizedlist>
				<listitem>In the first form, the <replaceable>set expression</replaceable> is assigned to the <replaceable>name</replaceable>.
		The complete set expression can be referenced by using the name
		anywhere a set expression is permitted.
		The result of the command is the assigned set expression,
		unchanged.</listitem>
				<listitem>In the second form, the <replaceable>transform</replaceable> is assigned to the name.
				The complete transform can be referenced by using the name
				anywhere a transform is permitted.
				The result of the command is an empty set expression.
				</listitem>
			</itemizedlist>
	  	</para>
	  </refsect1>
	</refentry>
    	<refentry id="r-unset">
	  <refnamediv>
	    <refname>unset</refname>
	    <refpurpose>Remove a name that has been defined</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
	    <cmdsynopsis><command>unset</command><arg choice="plain"><replaceable>name</replaceable></arg></cmdsynopsis>
	  </refsynopsisdiv>
	  <refsect1>
	    <title>Description</title>
		<para>This command removes the meaning, set expression or transform, associated with a name by a prior
		set command.
	  	</para>
	  </refsect1>
	</refentry>
	</sect1>
    <sect1 id="r-transforms">
    	<title>Transforms</title>
    	<para>Transforms change a set into another set.  You apply a transform
    	to the result of a set expression or another transform
    	by putting it in front.  <userinput><link linkend="r-methods-in">methods in</link></userinput>
    	is a transform that changes a set of classes to the set of methods
    	in those classes; applying it to the set expression
    	<programlisting>class "ObjectDB"</programlisting>
    	results in this set expression that returns the set of methods in that class:
    	</para>
    	<informalexample><programlisting>methods in class "ObjectDB"</programlisting></informalexample>
  		<para>Many transforms and value expressions represent the relationships between
objects in the &p-bbq; database;
use these to traverse the relationships
to get to your desired object type.</para>
<mediaobject>
<imageobject>
<imagedata fileref="../image/bbq/TransformRelationships.png"/>
</imageobject>
<textobject><phrase>(Diagram illustrating object relationships and transforms)</phrase></textobject>
</mediaobject>
		<para>
		Transforms can be combined with other transforms with <link linkend="r-set-operators">set operators</link>.
		This example returns a set of the derived classes of <userinput>Persistent</userinput>
		together with the class itself.
		</para>
  		<informalexample><programlisting>( derived classes of union same ) class "Persistent"</programlisting></informalexample>
  		<para>
  		Transforms can be used as arguments to some special operators
  		(<link linkend="r-exists"><userinput>exists</userinput></link>, <link linkend="r-group-of"><userinput>group of</userinput></link>,
  		<link linkend="r-recursive"><userinput>recursive</userinput></link>)
  		to create new filters, value expressions or transforms.  The following example
  		makes a <link linkend="r-filters">filter</link>
  		from the <userinput>fields in</userinput> transform,
  		to make a set expression that shows all the classes in package <userinput>com.antlersoft.odb</userinput>
  		that don't contain any fields.
  		</para>
  		<informalexample><programlisting>not exists ( fields in ) classes in package "com.antlersoft.odb"</programlisting></informalexample>
  		<refentry id="r-annotations-of">
  		  <refnamediv>
  		    <refname>annotations of</refname>
  		    <refpurpose>Returns any annotations of an element in the system</refpurpose>
  		  </refnamediv>
  		  <refsynopsisdiv>
  		    <synopsis>annotations of</synopsis>
  		  </refsynopsisdiv>
  		  <refsect1>
  		    <title>Description</title>
  		    <para>
  		    This transform returns all the annotations on the set of code elements to which it is applied.
  		    </para>
  		    <refsect2>
  		      <title>Example</title>
  		      <programlisting>annotations of methods in class "Foo"</programlisting>
  		      <para>This would return any annotations of the methods in class <userinput>Foo</userinput>.</para>
  		    </refsect2>
  		  </refsect1>
 		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-class">class</link></para>
		    <para><link linkend="r-type-member">member</link></para>
		    <para><link linkend="r-type-argument">argument</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-annotation">annotation</link></para>
		  </refsect1>
  		</refentry>
  		<refentry id="r-annotations-with">
  		  <refnamediv>
  		    <refname>annotations with</refname>
  		    <refpurpose>Returns all the annotations where the annotation class is the class supplied</refpurpose>
  		  </refnamediv>
  		  <refsynopsisdiv>
  		    <synopsis>annotations with</synopsis>
  		  </refsynopsisdiv>
  		  <refsect1>
  		    <title>Description</title>
  		    <para>Each annotation has a class which represents the type of the annotation.
  		    This transform applies to a set of classes, and returns the set of annotations with those
  		    classes.
  		    </para>
  		    <refsect2>
  		      <title>Example</title>
  		      <para><userinput>annotations with class "org.junit.After"</userinput></para>
  		      <para>This would return all the annotations with the class <userinput>org.junit.After</userinput>.</para>
  		    </refsect2>
  		  </refsect1>
 		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-annotation">annotation</link></para>
		  </refsect1>
  		</refentry>
  		<refentry id="r-any-class">
  		  <refnamediv>
  		    <refname>any class</refname>
  		    <refpurpose>Returns classes in any namespace/package with a given name</refpurpose>
  		  </refnamediv>
  		  <refsynopsisdiv>
  		    <synopsis>any class</synopsis>
  		  </refsynopsisdiv>
  		  <refsect1>
  		    <title>Description</title>
  		    <para>
  		    This transform applies to the <link linkend="r-type-string">string type</link> (often used with a string constant) and
  		    returns classes named by that string in any namespace or package.
  		    </para>
  		    <refsect2>
  		      <title>Example</title>
  		      <para><userinput>any class "ArrayList"</userinput></para>
  		      <para>This would return <userinput>java.util.ArrayList</userinput>.</para>
  		    </refsect2>
  		  </refsect1>
 		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-class">class</link></para>
		  </refsect1>
  		</refentry>
  		<refentry id="r-arguments-of">
		  <refnamediv>
		    <refname>arguments of</refname>
		    <refpurpose>Returns the arguments of the methods in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>arguments of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    The transform returns all the arguments for the methods in the set.
		    </para>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-argument">argument</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-arguments-with">
		  <refnamediv>
		    <refname>arguments with</refname>
		    <refpurpose>Returns all the arguments with the types in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>arguments with</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    For each type in the set, this transform returns all the method arguments,
		    for any method in the analyzed system, that have that type.  For a large system
		    and a common argument type (i.e. int), you can expect this to be a large set.
		    </para>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-argument">argument</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-base-classes">
		  <refnamediv>
			<refname>base classes of</refname>
			<refpurpose>Returns the base classes of the classes in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>base classes of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns the set of the immediate base
			classes and implemented interfaces for the classes in the set.
			It only looks back one level in the inheritance
			hierarchy.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-calls-from">
		  <refnamediv>
			<refname>calls from</refname>
			<refpurpose>Returns the set of all method calls found in a set of methods</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>calls from</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns all the method calls found
in the methods
in the set.
If you have two sets of methods, <userinput>foo</userinput> and <userinput>bar</userinput>,
and you want to identify all the places in foo
where bar is called, you might use:
<userinput>( calls from foo ) intersection ( calls to bar )</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-call">call</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-calls-to">
		  <refnamediv>
			<refname>calls to</refname>
			<refpurpose>Returns the set of all calls to methods in a set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>calls to</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns all the calls to methods
in the set.
If you have two sets of methods, <userinput>foo</userinput> and <userinput>bar</userinput>,
and you want to identify all the places in foo
where bar is called, you might use:
<userinput>( calls from foo ) intersection ( calls to bar )</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-call">call</link></para>
		  </refsect1>
		</refentry>
	  	<refentry id="r-cast">
	  	  <refnamediv>
	  	    <refname>cast</refname>
	  	    <refpurpose>Converts a set of objects to a known type</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
	  	    <cmdsynopsis>
	  	    	<command>cast</command>
	  	    	<group>
	  	    		<arg>arguments</arg>
	  	    		<arg>classes</arg>
	  	    		<arg>fields</arg>
	  	    		<arg>methods</arg>
	  	    	</group>
	  	    </cmdsynopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>
	  	    Some expressions (such as <userinput><link linkend="r-annotated-by">annotated by</link></userinput>)
	  	    might return results of any type.  This leads to a situation where you might know
	  	    better than the &p-bbq; parser what the result type of an expression is.  The <userinput>cast</userinput>
	  	    transform allows you to supply that knowledge back to the parser so you can add
	  	    further processing to the expression without the parser complaining about type safety.
	  	    </para>
	  	    <para><userinput>cast</userinput> forces the objects in the set to be interpreted
	  	    as the specified type; any objects that aren't convertible to that type
	  	    are dropped from the set.</para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following query returns methods annotated by annotations with the class <userinput>org.junit.After</userinput>
	  	      that do not call a method matching "finish."</para>
	  	      <informalexample>
	  	        <programlisting>not exists ( ~ "finish" methods called by calls from )
	  	        cast methods annotated by annotations with class "org.junit.After"</programlisting>
	  	      </informalexample>
	  	      <para>Note that without the <userinput>cast</userinput> transform,
	  	      the <userinput>calls from</userinput>
	  	      operator would produce a type mismatch error, since it can not be applied to
	  	      <link linkend="r-type-object"><userinput>object</userinput></link>.</para>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The type specified by the argument</para>
		  </refsect1>
	  	</refentry>
	  	<refentry id="r-catches-in">
	  	  <refnamediv>
	  	    <refname>catches in</refname>
	  	    <refpurpose>Returns the exception catches in a method</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
			<synopsis>catches in</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>
	  	    For each method in the set, this transform returns all the exception catches in the method.
	  	    </para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following returns the catches in method <userinput>Foo.Bar()</userinput></para>
	  	      <informalexample>
  	        	<programlisting>catches in ~ "Bar" methods in class "Foo"</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-catch">catch</link></para>
		  </refsect1>
	  	</refentry>
	  	<refentry id="r-catches-of">
	  	  <refnamediv>
	  	    <refname>catches of</refname>
	  	    <refpurpose>Finds catches of an exception class</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
			<synopsis>catches of</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>
	  	    Each catch statement in the analyzed system specifies an exception class to catch.  This
	  	    transform, applied to a set of classes, returns the set of catches of those classes.
	  	    </para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following query returns catches of <userinput>java.lang.Exception</userinput>.</para>
	  	      <informalexample>
	  	        <programlisting>catches of class "java.lang.Exception"</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-catch">catch</link></para>
		  </refsect1>
	  	</refentry>
		<refentry id="r-classes-in">
		  <refnamediv>
		    <refname>classes in</refname>
		    <refpurpose>Returns the classes in a set of packages, or the inner classes within a set of classes</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>classes in</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    This operator can represent two different transforms, depending on whether it is applied to a set
		    of packages or to a set of classes.
		    </para>
		    <itemizedlist>
		    	<listitem>When applied to a set of packages, the transform returns the classes
		    	in those packages.</listitem>
		    	<listitem>When applied to a set of classes, the transform returns the inner classes
		    	contained by those classes.</listitem>
		    </itemizedlist>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-class">class</link>, <link linkend="r-type-package">package</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-derived-classes">
		  <refnamediv>
			<refname>derived classes of</refname>
			<refpurpose>Returns the classes which are immediately
			derived from the classes in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>derived classes of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns the set of classes or interfaces
			that derive from, extend or implement
			the classes and interfaces in the set.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-fields-in">
		  <refnamediv>
			<refname>fields in</refname>
			<refpurpose>Returns the fields in the classes
			in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>fields in</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of classes, this transform returns
			the set of fields defined in those classes.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-field">field</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-fields-with">
		  <refnamediv>
		    <refname>fields with</refname>
		    <refpurpose>Returns all the fields with the types in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>fields with</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    For each type in the set, this transform returns all the fields
		    in the analyzed system that have that type.  For a large system
		    and a common type (i.e. int), you can expect this to be a large set.
		    </para>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-field">field</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-methods-in">
		  <refnamediv>
			<refname>methods in</refname>
			<refpurpose>Returns the methods in the classes
			in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>methods in</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of classes, this transform returns
			the set of methods that those classes contain.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-methods-with">
		  <refnamediv>
		    <refname>methods with</refname>
		    <refpurpose>Returns all the methods returning the types in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>fields with</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    For each type in the set, this transform returns all the methods
		    in the analyzed system that have that return type.  For a large system
		    and a common type (i.e. void), you can expect this to be a large set.
		    </para>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-packages-in">
		  <refnamediv>
		    <refname>packages in (Java)/namespaces in (C#-CIL)</refname>
		    <refpurpose>Returns the packages or namespaces nested in the packages or namespaces in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
		    <synopsis>packages in</synopsis>
		    <synopsis>namespaces in</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
		    <title>Description</title>
		    <para>
		    This transform returns the packages within the packages in the set.  It only
		    looks at the next nesting level of packages.  It is commonly used with the
		    <link linkend="r-recursive">recursive</link> operator to examine all the packages
		    nested at any level within a top-level package: <userinput>recursive ( packages in )</userinput>
		    </para>
		  </refsect1>
		  <refsect1>
		    <title>Applies to Type</title>
		    <para><link linkend="r-type-package">package/namespace</link></para>
		  </refsect1>
		  <refsect1>
		    <title>Results in Type</title>
		    <para><link linkend="r-type-package">package/namespace</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-polymorphic">
		  <refnamediv>
			<refname>polymorphic</refname>
			<refpurpose>Returns the set of methods that map polymorphically
to the input set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>polymorphic</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of methods, this transform returns those
methods in addition to methods with the same signature in base
or derived classes, that may be called polymorphically with the
input methods.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-recursive">
		<refnamediv>
			<refname>recursive</refname>
			<refpurpose>
			Recursively apply a transform,
			and possibly a secondary transform
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		<synopsis>
		recursive ( <replaceable>primary-transform</replaceable> )
		</synopsis>
		<synopsis>
		recursive ( <replaceable>primary-transform</replaceable>, <replaceable>secondary-transform</replaceable> )
		</synopsis>
		</refsynopsisdiv>
		<refsect1>
			<title>Description</title>
			<para>
			Sometimes you would like a transform to return an entire sub-tree
			of hierarchical data related to a program object.  &p-bbq; provides
			some special-purpose transforms (such as <link linkend="r-recursive-derived-classes">recursive derived classes</link>) for this purpose; this transform operator
			lets you recursively apply an arbitrary transform.
			Use care when using this operator, since you might accidentally
			specify a recursion that does not end (i.e. <userinput>recursive ( same )</userinput>).
			To prevent a hang or crash, the operator will stop recursing at an
			arbitrary depth (50).
			</para>
			<para>
			The effect of this transform operator can be most concisely
			described recursively:
				<itemizedlist>
					<listitem>
					The result of applying the first form of this transform to a set is the result
					of applying <replaceable>primary-transform</replaceable> to a set, combined with the result
					of applying this transform to that result.
					</listitem>
					<listitem>
					The result of applying the second form of this transform to a set
					is the result of applying <replaceable>primary-transform</replaceable> to the set,
					combined with the result of applying this transform to the result
					of applying <replaceable>secondary-transform</replaceable> to the result of applying
					<replaceable>primary-transform</replaceable> to the set.
					</listitem>
				</itemizedlist>
			</para>
			<refsect2>
				<title>Example</title>
				<para>
				To see the complete call tree starting with a particular method,
				use the transform:
				</para>
				<para>
				<userinput>
				recursive ( calls to, methods containing)
				</userinput>
				</para>
			</refsect2>
		</refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><replaceable>primary-transform</replaceable>'s Applies To type</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><replaceable>primary-transform</replaceable>'s Results type.  If this is not the
			same as the <replaceable>primary-transform</replaceable>'s Applies To type, a
			<replaceable>secondary-transform</replaceable> must be provided that applies to the Result type of <replaceable>primary-transform</replaceable> and results in its Applies To type.
		  	</para>
		  </refsect1>
		</refentry>
		<refentry id="r-recursive-base-classes">
		  <refnamediv>
			<refname>recursive base classes of</refname>
			<refpurpose>Returns the base classes of the classes in the set,
			and the base classes of those classes,
			to the root of the inheritance hierarchy</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>recursive base classes of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns the set of the base
			classes and implemented interfaces for the classes in the set,
			as well as the base classes of those classes
			and the interfaces extended by those interfaces,
			recursively.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-recursive-derived-classes">
		  <refnamediv>
			<refname>recursive derived classes of</refname>
			<refpurpose>Returns the derived classes of the classes in the set,
			and the derived classes of those classes,
			recursively</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>recursive derived classes of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This transform results in all the classes
			that extend or implement classes or interfaces in the original
			set, or in the derived classes.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-references-from">
		  <refnamediv>
			<refname>references from</refname>
			<refpurpose>Returns the set of all field references found in a set of methods</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>references from</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns all the field references found
in the methods
in the set.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-field-reference">field reference</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-references-to">
		  <refnamediv>
			<refname>references to</refname>
			<refpurpose>Return references to a string constant or a field</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>references to</synopsis>
			<synopsis>reference to</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This transform can be used on <link linkend="r-type-field">fields</link> to return references to those fields;
			alternatively, it can be used on <link linkend="r-type-string-constant">string constants</link> to return references to those constants.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-field">field</link></para>
		  	<para><link linkend="r-type-string-constant">string constant</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-field-reference">field reference</link></para>
		  	<para><link linkend="r-type-string-constant-reference">string constant reference</link></para>
		  </refsect1>
		</refentry>
	  	<refentry id="r-resources-containing">
	  	  <refnamediv>
	  	    <refname>resources containing</refname>
	  	    <refpurpose>Finds the string resource that's value is a given string constant</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
			<synopsis>resources containing</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>
	  	    Applied to a set of <userinput><link linkend="r-type-string-constant">string constants</link></userinput>,
	  	    this transform returns the set of <userinput>string resources</userinput>
	  	    that have a value equal to one of the constants.
	  	    </para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following query returns resources that contain strings that match "Foo":</para>
	  	      <informalexample>
	  	        <programlisting>resources containing ~ "Foo" all strings</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string-constant">object</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string-resource">string resource</link></para>
		  </refsect1>
	  	</refentry>
	  	<refentry id="r-resources-with-names">
	  	  <refnamediv>
	  	    <refname>resources with names</refname>
	  	    <refpurpose>Finds the string resource that's name is a given string constant</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
			<synopsis>resources with names</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>
	  	    Applied to a set of <userinput><link linkend="r-type-string-constant">string constants</link></userinput>,
	  	    this transform returns the set of <userinput>string resources</userinput>
	  	    that have a name equal to one of the constants.
	  	    </para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following query returns resources named "Foo":</para>
	  	      <informalexample>
	  	        <programlisting>resources with names string "Foo"</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string-constant">object</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string-resource">string resource</link></para>
		  </refsect1>
	  	</refentry>
		<refentry id="r-same">
		  <refnamediv>
			<refname>same</refname>
			<refpurpose>A transform that leaves the set unchanged</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>same</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
		  	<para>This transform is typically used
		  	with the set operators to obtain compound transforms
		  	that reference the original set.
		  	For example, the <userinput>recursive base classes of</userinput>
		  	transform does not include the original set in the output;
		  	you can include the original set in the output with
		  	this transform: <userinput>recursive base classes of union same</userinput>.
		  	</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>Any</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The result type is the type of the set expression
		  	applied.
		  	</para>
		  </refsect1>
		</refentry>
		<refentry id="r-string-constant-references-from">
		  <refnamediv>
			<refname>string references from</refname>
			<refpurpose>Returns the set of all string constant references found in a set of methods</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>string references from</synopsis>
			<highlights>
				<itemizedlist>
					<listitem>stateless</listitem>
				</itemizedlist>
			</highlights>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The transform returns all the string constant references found
in the methods
in the set.
If you have a set of methods foo, and a string constant "bar",
you can find all the references to "bar" from the methods in foo
with <userinput>( string references from foo ) intersection ( references to string "bar" )</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string-constant-reference">string constant reference</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-uncorrelated">
		  <refnamediv>
			<refname>uncorrelated</refname>
			<refpurpose>Change a set to another, specified set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>uncorrelated ( <replaceable>set expression</replaceable> )</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
		  	<para>
In special circumstances, you might wish to use a set expression
where the language normally calls for a transform.
This transform replaces any set with the result
of the <replaceable>set expression</replaceable> argument provided.
		  	</para>
		  	<refsect2>
		  		<title>Example</title>
		  		<para>In this (somewhat contrived) example,
		  		the expression returns the methods in <userinput>ObjectDB</userinput>
		  		only if the result of the previous set expression was not empty:
		  		</para>
		  		<informalexample>
		  			<programlisting>exists ( uncorrelated ( previous ) ) methods in class "ObjectDB"</programlisting>
		  		</informalexample>
		  	</refsect2>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>Any</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The result type is the type of the supplied
<replaceable>set expression</replaceable> argument.
		  	</para>
		  </refsect1>
		</refentry>
		<refentry id="r-unique">
		  <refnamediv>
			<refname>unique</refname>
			<refpurpose>Remove duplicate elements in a set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>unique</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
		  	<para>
This transform returns only one instance of each object in the transformed set; duplicate
instances are discarded.
		  	</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>Any</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The result type is the type of the transformed set expression.
		  	</para>
		  </refsect1>
		</refentry>
  	</sect1>
 	<sect1 id="r-value-expressions">
  		<title>Value Expressions</title>
  		<para>
  		Count-preserving and group value expressions share many of the properties of transforms.<footnote id="fn-value-expression"><para>Some value expressions
  		were transforms in previous releases of the language; they can still be used
  		as transforms, and also used with value-expression specific operators.</para></footnote>
        Scalar value expressions can be used as simple set-expressions, as well as with value operators.
  		The available value expressions
  		are listed including the context in which they may be applied.
  		</para>
  		<sect2>
  			<title>Examples</title>
	  		<para>
	  		Here, a group-context value expression is used as a transform to change the
	  		set of methods in a class to the count of the
	  		number of methods in the class:
	  		</para>
	  		<informalexample>
	  			<programlisting>count methods in class "ObjectDB"</programlisting>
	  		</informalexample>
	  		<para>
	  		Here, the group-context value expression is converted into a count-preserving
	  		value expression with the <link linkend="r-group-of">group of</link>
	  		operator, and that is compared with a scalar expression (a numeric constant)
	  		with a <link linkend="r-relational-operators">relational operator</link>
	  		to make a filter that is applied to the set expression.
	  		</para>
	  		<informalexample>
	  			<programlisting>( count of ( arguments of ) > 1 ) methods in class "ObjectDB"</programlisting>
	  		</informalexample>
	  	</sect2>
	  	<refentry id="r-annotated-by">
	  	  <refnamediv>
	  	    <refname>annotated by</refname>
	  	    <refpurpose>Returns the object that is annotated by an annotation</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
	  	    <synopsis>annotated by</synopsis>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>This expression applies to an <link linkend="r-type-annotation">annotation</link>
	  	    object and returns the object that it annotates, which can be a
	  	    <link linkend="r-type-class">class</link>,
	  	    <link linkend="r-type-method">method</link>,
	  	    <link linkend="r-type-field">field</link> or
	  	    <link linkend="r-type-argument">argument</link>.
	  	    Since the returned type is unknown, you will often use <userinput>annotated by</userinput>
	  	    in conjunction with the <link linkend="r-cast"><userinput>cast</userinput></link>
	  	    operator if you want to further process the results.
	  	    </para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following query returns the objects annotated by annotations with the class <userinput>org.junit.After</userinput></para>
	  	      <informalexample>
	  	        <programlisting>annotated by annotations with class "org.junit.After"</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-annotation">annotation</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
	  	</refentry>
	  	<refentry id="r-array-of">
	  	  <refnamediv>
	  	    <refname>array of</refname>
	  	    <refpurpose>Returns a type that is an array of the supplied type</refpurpose>
	  	  </refnamediv>
	  	  <refsynopsisdiv>
	  	    <synopsis>array of</synopsis>
	  	  </refsynopsisdiv>
	  	  <refsect1>
	  	    <title>Description</title>
	  	    <para>The value of this expression is the <link linkend="r-type-type">type</link> object
	  	    representing an array of the type to which it is applied.</para>
	  	    <refsect2>
	  	      <title>Example</title>
	  	      <para>The following set expression searches the entire analyzed system for
	  	      any method that returns a type that is an array of the method's first argument.</para>
	  	      <informalexample>
	  	        <programlisting>exists ( ( methods with array of type of first of ( arguments of ) ) intersection same ) methods in all classes</programlisting>
	  	      </informalexample>
	  	    </refsect2>
	  	  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
	  	</refentry>
		<refentry id="r-bundles-containing">
		  <refnamediv>
			<refname>bundles containing</refname>
			<refpurpose>Returns the bundles containing a string resource</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>bundles containing</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of <link linkend="r-type-string-resource"><userinput>string resources</userinput></link>
			this transform returns the bundles that contain those resources.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string-resource">string resource</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-bundle">bundle</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-classes-containing">
		  <refnamediv>
			<refname>classes containing</refname>
			<refpurpose>Returns the classes that contain the class members in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>classes containing</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of methods, or a set of fields, this transform returns
			the set of classes in which those methods or fields are defined.
			Applied to an inner class, it returns the class that contains the inner class.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  	<para><link linkend="r-type-member">member</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-classes-of">
		  <refnamediv>
			<refname>classes of</refname>
			<refpurpose>Returns the class of an annotation</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>classes of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to an annotation, returns the <link linkend="r-type-class">class</link> of the
			annotation.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-annotation">annotation</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-classes-with">
		  <refnamediv>
			<refname>classes with</refname>
			<refpurpose>Returns the classes that are referenced by the types in the set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>classes with</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to a set of types, returns the classes that the types reference.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-count">
		  <refnamediv>
			<refname>count</refname>
			<refpurpose>return the number of items in a set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>count</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This expression returns the number of items in a set.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Group</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-integer">integer</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-each">
		  <refnamediv>
			<refname>each</refname>
			<refpurpose>Makes the value of a set item available in a value expression unchange</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>each</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			This is the equivalent of the <link linkend="r-same"><userinput>same</userinput></link>
			transform except for value expressions.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>Any</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>Same as Applies to Type</para>
		  </refsect1>
		</refentry>
		<refentry id="r-fields-referenced-by">
		  <refnamediv>
			<refname>fields referenced by</refname>
			<refpurpose>Returns the fields referenced by a
set of field references</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>fields referenced by</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to a field reference object, this value expression returns the field referenced.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-field-reference">field reference</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-field">field</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-first">
		  <refnamediv>
			<refname>first</refname>
			<refpurpose>Return the first item in a set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>first</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This expression returns the first item produced in a set.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Group</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>Any</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The type of the underlying expression</para>
		  </refsect1>
		</refentry>
		<refentry id="r-group-of">
		  <refnamediv>
			<refname>group of</refname>
			<refpurpose>Create a count-preserving expression from a group value expression</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis><replaceable>group-value-expression</replaceable> of ( <replaceable>transform</replaceable> )</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This construction allows you to make a count-preserving value expression from a
			group value expression.</para>
			<para>When this expression is evaluated for an object,
			<replaceable>transform</replaceable> is applied to the object,
			and the result of the expression is the result of <replaceable>group-value-expression</replaceable>
			applied to the resulting set.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>The applicable type of <replaceable>transform</replaceable></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para>The result type of <replaceable>group-value-expression</replaceable></para>
		  </refsect1>
		</refentry>
		<refentry id="r-methods-called-by">
		  <refnamediv>
			<refname>methods called by</refname>
			<refpurpose>Returns the methods called be a set of calls</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>methods called by</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to a call object, this expression returns the set method
that is called.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-call">call</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-methods-containing">
		  <refnamediv>
			<refname>methods containing</refname>
			<refpurpose>Returns the methods containing
			a set of references</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>methods containing</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to a reference object, returns the method
where that reference were found.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-reference">reference</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-methods-of">
		  <refnamediv>
			<refname>methods of</refname>
			<refpurpose>Returns the method of an argument</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>methods of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to an argument, returns the method that has that argument.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-argument">argument</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-names-of">
		  <refnamediv>
			<refname>names of</refname>
			<refpurpose>Returns the string constant representing the name of a string resource</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>names of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			String resources have a name and a value; applied to a string resource object, this
			expression returns the string constant that is its name.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string-resource">string resource</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string-constant">string constant</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-number-value">
		  <refnamediv>
			<refname>number</refname>
			<refpurpose>a numeric constant</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis><replaceable>digits</replaceable></synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>A number that appears as a constant scalar expression.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Scalar</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-integer">integer</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-packages-of">
		  <refnamediv>
			<refname>packages of (Java)/namespaces of (C#/CIL)</refname>
			<refpurpose>Returns the package that contains a class</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>packages of</synopsis>
			<synopsis>namespaces of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to a class, returns the package or namespace that contains that class.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-package">package</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-string-value">
		  <refnamediv>
			<refname>string expression</refname>
			<refpurpose>a string</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>"some string"</synopsis>
			<synopsis>//some string/</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>A quoted string that is not part of another operator is a scalar value expression,
			with the value being that string.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Scalar</para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-strings-referenced-by">
		  <refnamediv>
			<refname>strings referenced by</refname>
			<refpurpose>Returns the string referenced by a string reference</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>strings referenced by</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applied to string constant reference object, this expression returns the string constant that is referenced.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string-constant-reference">string constant reference</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string-constant">string constant</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-substitute">
			<refnamediv>
				<refname>substitute</refname>
				<refpurpose>Change a string by regular expression substitution</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<synopsis>substitute(<replaceable>from</replaceable>,<replaceable>match pattern</replaceable>)</synopsis>
				<synopsis>substitute(<replaceable>from</replaceable>,<replaceable>match pattern</replaceable>,<replaceable>result pattern</replaceable>)</synopsis>
			</refsynopsisdiv>
		    <refsect1>
		    	<title>Description</title>
		    	<para>This expression changes a string into another string with regular
		    	expression matching.
		    	<itemizedlist>
		    		<listitem><simpara>In the first form,
		    		the result is the portion of
		    		the string value expression <replaceable>from</replaceable>
		    		that matches <replaceable>match pattern</replaceable>.
		    		</simpara></listitem>
		    		<listitem><simpara>In the second form,
		    		the result is the <replaceable>result pattern</replaceable>
		    		applied to the result of matching <replaceable>from</replaceable>
		    		with the <replaceable>match pattern</replaceable>.</simpara></listitem>
		    	</itemizedlist>
		    	</para>
			  <refsect2>
			  	<title>Example</title>
			  	<para>
			  	This expression returns the last component (following the period) of all the package names.
			  	</para>
			  	<informalexample>
			  		<programlisting>substitute( to string, //.*\./, ///) all packages</programlisting>
			  	</informalexample>
			  </refsect2>
		    </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-to-string">
			<refnamediv>
				<refname>to string</refname>
				<refpurpose>Converts an object to its string representation</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<synopsis>to string</synopsis>
			</refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			Applied to any object, <userinput>to string</userinput> returns its string representation as a string-typed value.
			Usually &p-bbq; does this for you when necessary, but this operator allows you to explicitly convert
			an object into a string value where a string-valued expression is required.
			</para>
			  <refsect2>
			  	<title>Example</title>
			  	<para>
			  	This expression returns the last component (following the period) of all the package names.
			  	</para>
			  	<informalexample>
			  		<programlisting>substitute( to string, //.*\./, ///) all packages</programlisting>
			  	</informalexample>
			  </refsect2>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-type">
		  <refnamediv>
			<refname>type</refname>
			<refpurpose>Returns the type named by a certain string</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>type</synopsis>
			<synopsis>types</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para><userinput>type</userinput> returns the type named by a string.
			For reference types, the complete name of the class should be included in the string.
			For array types, add [] to the end of the string for each array dimension.
			</para>
			<para>
			Examples:
			</para>
			<para><userinput>type "void"</userinput></para>
			<para><userinput>type "int[]"</userinput></para>
			<para><userinput>type "java.util.Vector"</userinput></para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-string">string</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-type-of">
		  <refnamediv>
			<refname>type of</refname>
			<refpurpose>return the type that references a class, or the type of a field or an argument,
			or the return type of a function.</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>type of</synopsis>
			<synopsis>types of</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para><userinput>type of</userinput> can be applied
			to argument, class, field or method objects.
			When applied to arguments or fields, it returns the type of the
			argument or field.
			When applied to a method, it returns the return type of the method.
			When applied to a class, it returns the type that references that class.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-argument">argument</link></para>
		  	<para><link linkend="r-type-class">class</link></para>
		  	<para><link linkend="r-type-field">field</link></para>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-type-referenced-by">
		  <refnamediv>
			<refname>type referenced by</refname>
			<refpurpose>Returns the type that an array type is an array of</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>type referenced by</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
Applies to a type that is an array type, this returns the type of the members of an array.
If the array is multi-dimensional, this will effectively strip off one dimension of the array.
If the type does not represent a reference type, this will expression will return null.
			</para>
		  </refsect1>
		  <refsect1>
		  	<title>Context</title>
		  	<para>Count-Preserving</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		  <refsect1>
			<title>Results in Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
		</refentry>
  	</sect1>
    <sect1 id="r-filters">
    	<title>Filters</title>
  		<para>A filter transforms a set by applying a boolean check
to each member of the set individually;
if the check succeeds, the member is included in the
result set.</para>
		<para>Like transforms, filters are applied to the front of a set expression.
		For example, <link linkend="r-interface"><userinput>interface</userinput></link>
		is a filter that applies to classes and passes only those classes that are interfaces.
		So the set expression
		</para>
		<informalexample><programlisting>interface classes in package "org.eclipse.core.runtime"</programlisting></informalexample>
		<para>
		returns the interfaces that are in the <userinput>org.eclipse.core.runtime</userinput> package.
		</para>
		<refentry id="r-tilde">
			<refnamediv>
				<refname>~</refname>
				<refpurpose>Regular-expression match on an object name</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<cmdsynopsis><command>~</command><arg><replaceable>regular-expression</replaceable></arg></cmdsynopsis>
			</refsynopsisdiv>
			<refsect1>
				<title>Description</title>
				<para>This filter returns only those objects in the set that match <replaceable>regular-expression</replaceable>.
				The regular expression is a Java regular expression (even when you are using BBQ-IL), as described
				in <ulink url="https://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">the documentation
				for <userinput>java.util.regex.Pattern</userinput></ulink>.</para>
				<refsect2>
					<title>Example</title>
					<para>One of the most useful applications of regular expression matching is to do case-insensitive
					searching.  The following expression finds references to all strings in the analyzed system that
					contain "select", regardless of case.</para>
					<informalexample>
						<programlisting>references to ~ "(?i)select" all strings</programlisting>
					</informalexample>
				</refsect2>
			</refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-abstract">
		  <refnamediv>
			<refname>abstract</refname>
			<refpurpose>Checks whether a class or method was declared
abstract</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>abstract</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>These filters apply to class or method
set expressions
and let you test whether the set member was declared abstract.
Note that all interfaces are implicitly abstract,
so if you are really interested only in classes you have
to explicitly exclude interfaces, as with
the compound filter <userinput>not interface abstract</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
        </refentry>
		<refentry id="r-deprecated">
		  <refnamediv>
			<refname>deprecated</refname>
			<refpurpose>Checks whether a class, field or method is marked deprecated</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>deprecated</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This filter tests whether a member of the set
			is marked as being deprecated.
			</para>
			<refsect2>
				<title>Example</title>
				<para>This query returns the set of all calls to deprecated methods in classes in
				<userinput>org.eclipse.core.runtime</userinput>:</para>
				<informalexample>
					<programlisting>calls to deprecated methods in classes in package "org.eclipse.core.runtime"</programlisting>
				</informalexample>
			</refsect2>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  	<para><link linkend="r-type-field">field</link></para>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
        </refentry>
		<refentry id="r-exists">
		  <refnamediv>
			<refname>exists</refname>
			<refpurpose>Checks if a transform applied to each member of a set returns an empty set</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>exists ( <replaceable>transform</replaceable> )</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>To determine if an object
passes the test it is first
converted to a set
containing only that object;
the <replaceable>transform</replaceable> is applied to that set;
the filter passes if the result of the transform has at least one member.
			</para>
			<para>
			If <replaceable>transform</replaceable> is not <link linkend="r-stateless">stateless</link>
			keep in mind that it will be applied as if each element filtered
			comprises its own separate set.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para>The Applies To type of <replaceable>transform</replaceable></para>
		  </refsect1>
		</refentry>
		<refentry id="r-interface">
		  <refnamediv>
			<refname>interface</refname>
			<refpurpose>Checks whether a class object is an interface</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>interface</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This filter tests whether a member of the set
of <link linkend="r-type-class">class</link> objects is in fact
an interface.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  </refsect1>
        </refentry>
		<refentry id="r-is-array">
		  <refnamediv>
			<refname>is array</refname>
			<refpurpose>Checks whether a type is an array type</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>is array</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This filter tests whether a member of a set of types is an array type.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
        </refentry>
		<refentry id="r-is-reference-type">
		  <refnamediv>
			<refname>is reference type (Java), is class type (C#/CIL)</refname>
			<refpurpose>Checks whether a type is a reference type or a built-in type</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>is reference type (Java)</synopsis>
			<synopsis>is class type (C#/CIL)</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>This filter tests whether a member of a set of types is a reference type (that is,
			a class or an array type, as opposed to a built-in value type).
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-type">type</link></para>
		  </refsect1>
        </refentry>
		<refentry id="r-matching">
		  <refnamediv>
			<refname>matching</refname>
			<refpurpose>Checks if a string matches the name of the object</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>matching <replaceable>string</replaceable></synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The test passes if <replaceable>string</replaceable> matches some part of the
object's name.  This filter does a simple string match; for regular expression matching, use the
<link linkend="r-tilde">~ filter</link>.
			</para>
			<refsect2>
				<title>Example</title>
				<para>This expression returns classes with names containing "DB" in <userinput>com.antlersoft.analyzer</userinput>.</para>
				<informalexample><programlisting>matching "DB" classes in package "com.antlersoft.analyzer"</programlisting></informalexample>
			</refsect2>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-object">object</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-package-etc">
		  <refnamediv>
			<refname>package (Java), private, protected, public, internal (C#/CIL)</refname>
			<refpurpose>Checks the visibility of a class/method/field</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>package (Java)</synopsis>
			<synopsis>private</synopsis>
			<synopsis>protected</synopsis>
			<synopsis>public</synopsis>
			<synopsis>internal (C#/CIL)</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>These filters apply to class, method, or field types,
and let you test the visibility with which the object was declared.
Use <userinput>private</userinput>, <userinput>public</userinput>,
or <userinput>protected</userinput> to test if the program
object was declared with that visibility modifier,
or use <userinput>package</userinput>
to test if it was declared with the default visibility.
			</para>
			<para>
			For BBQ-IL, package is not applicable; you can use <userinput>internal</userinput>
			to test if something was declared with internal visibility.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-class">class</link></para>
		  	<para><link linkend="r-type-field">field</link></para>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-static">
		  <refnamediv>
			<refname>static</refname>
			<refpurpose>Checks whether a field or method is static</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>static</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>
			A method or a field passes this filter if it is declared as static.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-field">field</link></para>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-uncalled">
		  <refnamediv>
			<refname>uncalled</refname>
			<refpurpose>Checks if there is any call to the method</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>uncalled</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>A method passes this filter if there is no call to it in
the analyzed system.  Equivalent to the filter <userinput>not exists ( calls to )</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-uncalled-polymorphic">
		  <refnamediv>
			<refname>uncalled polymorphic</refname>
			<refpurpose>Checks if there is any polymorphic call to the method</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>uncalled</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>A method passes this filter if there is no call to it,
or any polymorphic method that might resolve to it, in
the analyzed system.  Equivalent to the filter <userinput>not exists ( calls to polymorphic )</userinput>.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-method">method</link></para>
		  </refsect1>
		</refentry>
		<refentry id="r-write">
		  <refnamediv>
			<refname>write</refname>
			<refpurpose>Checks if a field reference is read or write</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<synopsis>write</synopsis>
		  </refsynopsisdiv>
		  <refsect1>
			<title>Description</title>
			<para>The test passes if the field reference is a write reference:
if it updates the value of the field.
			</para>
		  </refsect1>
		  <refsect1>
			<title>Applies to Type</title>
		  	<para><link linkend="r-type-field-reference">field reference</link></para>
		  </refsect1>
		</refentry>
  	</sect1>
   	<sect1 id="r-operators">
  		<title>Operators</title>
  		<para>The language supports set operators, logical operators, and value operators.</para>
  		<sect2 id="r-set-operators">
  			<title>Set Operators</title>
  			<para>Set operators combine two set expressions or two transforms in different ways:</para>
  			<variablelist>
  				<varlistentry>
  					<term>union</term>
  					<listitem>
  					<para>The <userinput>union</userinput> operator combines all the elements of two sets.  The following
  					transform will return all method calls or field references to members of a class:</para>
  					<informalexample>
  						<programlisting>set CallOrRefTransform to ( calls to methods in ) union ( references to fields in )</programlisting>
  					</informalexample>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>intersection</term>
  					<listitem>
  					<para>The <userinput>intersection</userinput> operator creates a set containing only those elements that appear in both
  					operand sets.  The following set expression will return calls to a class that come from methods in the class:</para>
  					<informalexample>
  						<programlisting>( calls to intersection calls from ) methods in class "ObjectDB"</programlisting>
  					</informalexample>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>without</term>
  					<listitem>
  					<para>The <userinput>without</userinput> operator creates a set containing only those elements in the first operand
  					set that do not also exist in the second operand set.  This operation is sometimes referred to as "difference".
  					The following set expression will return calls to class that come from methods outside the class:</para>
  					<informalexample>
  						<programlisting>( calls to without calls from ) methods in class "ObjectDB"</programlisting>
  					</informalexample>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>deintersection</term>
  					<listitem>
  					<para>The <userinput>deintersection</userinput> operator creates a set containing only those elements that appear
  					in one of the operand sets that don't appear in both operand sets.  This operation is sometimes referred to as "symmetric difference".</para>
  					</listitem>
  				</varlistentry>
  			</variablelist>
  		</sect2>
  		<sect2 id="r-logical-operators">
  			<title>Logical Operators</title>
  			<para>Logical operators let you combine filters into different filters.</para>
 			<variablelist>
  				<varlistentry>
  					<term>and</term>
  					<listitem>
  					<para>The <userinput>and</userinput> operator results in a filter that passes a value only
  					if it passes both operand filters.</para>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>or</term>
  					<listitem>
  					<para>The <userinput>or</userinput> operator results in a filter that passes a value if either
  					of the operand filters pass the value.</para>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>xor</term>
  					<listitem>
  					<para>The <userinput>xor</userinput> operator results in a filter that passes a value if either
  					of the operand filters, but not both, pass the value.</para>
  					</listitem>
  				</varlistentry>
  				<varlistentry>
  					<term>not</term>
  					<listitem>
  					<para>The <userinput>not</userinput> operator applies to a single filter and
  					changes its sense, so that it rejects values it would pass and passes values
  					it would reject.</para>
  					</listitem>
  				</varlistentry>
  			</variablelist>
  		</sect2>
  		<sect2 id="r-value-operators">
  			<title>Value Operators</title>
  			<para>
  			There are two kinds of operators that work only with value expressions: relational operators and
  			value operators.
  			</para>
  			<sect3 id="r-relational-operators">
  				<title>Relational Operators</title>
  				<para>
  				&p-bbq; supports relational operators that compare two value expressions; the result of
  				the comparison is a filter.  The <userinput>=</userinput> and <userinput>!=</userinput>
  				operators can compare any value expression type;
  				the relational operators <userinput>&lt; &lt;= >= ></userinput>
  				can only compare values of type <link linkend="r-type-integer">integer</link>,
  				<link linkend="r-type-string">string</link>, or <link linkend="r-type-date">date</link>.
  				</para>
  				<para>
  				There is an additional relational operator <userinput>~=</userinput> that produces a filter by
  				matching a string value
  				with a second string value interpreted as a Java regular expression.  The following set expression
  				looks for strings that match "select", regardless of case:
  				<informalexample>
  					<programlisting>to string ~= //(?i)select/ all strings</programlisting>
  				</informalexample>
  				</para>
  			</sect3>
  			<sect3 id="r-value-expression-operators">
  				<title >Value Expression Operators</title>
  			<para>Value operators combine two value expressions into a single value expression.</para>
  			<para>&p-bbq; currently defines only one value operator, <userinput>&amp;</userinput>.
  			This operator concatenates two <link linkend="r-type-string">string</link>-type expressions.
  			</para>
  			</sect3>
  		</sect2>
  	</sect1>
  </chapter>
  <appendix>
	<title>Grammar Summary</title>
  	<para>
  	The following is a summary of the grammar of the Java query language.
  	</para>
  	<programlisting>
COMPLETE_QUERY : SET_EXPRESSION 
	| DELIMITED_QUERY 
	;
SET_EXPRESSION : SET_EXPRESSION SET_OPERATOR SET_EXPRESSION 
	| '(' SET_EXPRESSION ')' 
	| VALUE_LIST 
	| 'execute' SET_EXPRESSION 
	| 'previous' 
	| literalString 
	| 'all' 'annotations' 
	| 'unset' nameSymbol 
	| SAVING_NAME SET_EXPRESSION 
	| SAVING_NAME TRANSFORM 
	| VALUE_EXPRESSION SET_EXPRESSION 
	| SET_EXPRESSION 'that' Identity FILTER 
	| 'class' literalString 
	| 'package' literalString 
	| 'all' 'classes' 
	| 'all' StringConstant 
	| 'all' 'packages' 
	| ImportExpression 
	| TRANSFORM SET_EXPRESSION
	# or the name of a saved set expression
	;
DELIMITED_QUERY : SET_EXPRESSION ';' 
	| DELIMITED_QUERY ';' 
	| DELIMITED_QUERY SET_EXPRESSION 
	;
SET_OPERATOR : 'union' 
	| 'intersection' 
	| 'deintersection' 
	| 'without' 
	;
VALUE_LIST : '(' ')' 
	| 'list' 
	| 'list' VALUE_EXPRESSION 
	| VALUE_EXPRESSION ',' VALUE_EXPRESSION 
	| VALUE_LIST ',' VALUE_EXPRESSION 
	;
SAVING_NAME : 'set' nameSymbol 'to' 
	;
TRANSFORM : 'same' 
	| FILTER 
	| TRANSFORM SET_OPERATOR TRANSFORM 
	| '(' TRANSFORM ')' 
	| VALUE_EXPRESSION 
	| 'recursive' '(' TRANSFORM ')' 
	| 'recursive' '(' TRANSFORM ',' TRANSFORM ')' 
	| 'uncorrelated' '(' SET_EXPRESSION ')' 
	| 'unique' 
	| 'cast' TypeSpec 
	| 'annotations' 'of' 
	| 'annotations' 'with' 
	| VALUE_EXPRESSION TRANSFORM 
	| TRANSFORM TRANSFORM 
	| TRANSFORM 'that' Identity FILTER 
	| 'arguments' 'of' 
	| 'any' 'class' 
	| 'recursive' 'base' 'classes' 'of' 
	| 'base' 'classes' 'of' 
	| 'recursive' 'derived' 'classes' 'of' 
	| 'derived' 'classes' 'of' 
	| 'methods' 'in' 
	| 'fields' 'in' 
	| 'polymorphic' 
	| 'calls' 'from' 
	| Reference 'from' 
	| StringConstant Reference 'from' 
	| Reference 'to' 
	| 'calls' 'to' 
	| 'catches' 'of' 
	| 'catches' 'in' 
	| 'fields' 'with' 
	| 'methods' 'with' 
	| 'arguments' 'with' 
	| 'packages' 'in' 
	| 'classes' 'in' 
	| 'resources' 'containing' 
	| 'resources' 'with' 'names' 
	# or the name of a saved transform
	;
VALUE_EXPRESSION : literalString 
	| number 
	| 'to' 'string' 
	| '(' VALUE_EXPRESSION ')' 
	| 'substitute' '(' VALUE_EXPRESSION ',' VALUE_EXPRESSION ')' 
	| 'substitute' '(' VALUE_EXPRESSION ',' VALUE_EXPRESSION ',' VALUE_EXPRESSION ')' 
	| GROUP_EXPRESSION 
	| VALUE_EXPRESSION '&amp;' VALUE_EXPRESSION 
	| 'same' 
	| 'each' 
	| GROUP_EXPRESSION 'of' '(' TRANSFORM ')' 
	| 'date' '(' literalString ')' 
	| 'annotated' 'by' 
	| 'classes' 'of' 
	| Types 'of' 
	| VALUE_EXPRESSION VALUE_EXPRESSION 
	| StringConstant 
	| Types 
	| 'classes' 'containing' 
	| 'classes' 'with' 
	| 'methods' 'containing' 
	| 'methods' 'called' 'by' 
	| 'fields' 'referenced' 'by' 
	| StringConstant 'referenced' 'by' 
	| 'type' 'referenced' 'by' 
	| 'methods' 'of' 
	| 'packages' 'of' 
	| 'names' 'of' 
	| 'bundles' 'containing' 
	| 'array' 'of' 
	;
Identity : 'is' 
	| 'are' 
	;
FILTER : 'not' FILTER 
	| 'exists' '(' TRANSFORM ')' 
	| '(' FILTER ')' 
	| FILTER 'and' FILTER 
	| FILTER 'or' FILTER 
	| FILTER 'xor' FILTER 
	| VALUE_EXPRESSION RELATIONAL_OPERATOR VALUE_EXPRESSION 
	| VALUE_EXPRESSION '~=' VALUE_EXPRESSION 
	| '~' literalString 
	| 'matching' literalString 
	| 'write' 
	| 'is' 'array' 
	| 'is' 'reference' 'type' 
	| 'public' 
	| 'private' 
	| 'protected' 
	| 'package' 
	| 'abstract' 
	| 'static' 
	| 'interface' 
	| 'deprecated' 
	| 'uncalled' 
	| UncalledPolymorphic 
	;
StringConstant : 'string' 
	| 'strings' 
	;
ImportExpression : 'import' 
	| ImportExpression 'set' 
	| ImportExpression literalString 
	;
TypeSpec : 'methods' 
	| 'fields' 
	| 'arguments' 
	| 'classes' 
	;
Reference : 'reference' 
	| 'references' 
	;
GROUP_EXPRESSION : 'count' 
	| 'first' 
	;
Types : 'type' 
	| 'types' 
	;
RELATIONAL_OPERATOR : '&lt;' 
	| '&lt;=' 
	| '=' 
	| '!=' 
	| '>=' 
	| '>' 
	;
UncalledPolymorphic : 'uncalled' 'polymorphic' 
	;

  	</programlisting>
  </appendix>
</book>
